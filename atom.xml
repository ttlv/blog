<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ttlv.github.io/blog</id>
    <title>Gopher From Ghetto</title>
    <updated>2021-01-17T14:53:08.951Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ttlv.github.io/blog"/>
    <link rel="self" href="https://ttlv.github.io/blog/atom.xml"/>
    <subtitle>stay hungry,stay foolish</subtitle>
    <logo>https://ttlv.github.io/blog/images/avatar.png</logo>
    <icon>https://ttlv.github.io/blog/favicon.ico</icon>
    <rights>All rights reserved 2021, Gopher From Ghetto</rights>
    <entry>
        <title type="html"><![CDATA[Golang性能调优]]></title>
        <id>https://ttlv.github.io/blog/post/golang-xing-neng-diao-you/</id>
        <link href="https://ttlv.github.io/blog/post/golang-xing-neng-diao-you/">
        </link>
        <updated>2021-01-17T14:50:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-性能调优过程">1. 性能调优过程</h2>
<p>性能调试总体思路</p>
<figure data-type="image" tabindex="1"><img src="https://images-1253546493.cos.ap-shanghai.myqcloud.com/golang_performance.jpg" alt="image-20200802051340009" loading="lazy"></figure>
<h2 id="2-常见的分析指标">2. 常见的分析指标</h2>
<h3 id="1-wall-time">1. Wall Time</h3>
<p>即墙上时钟时间（wall clock time）：从进程从开始运行到结束，时钟走过的时间，这其中包含了进程在阻塞和等待状态的时间。</p>
<h3 id="2-cpu-time">2. CPU Time</h3>
<h4 id="1-用户cpu时间">1. 用户CPU时间</h4>
<p>就是用户的进程获得了CPU资源以后，在用户态执行的时间</p>
<h4 id="2-系统cpu时间">2. 系统CPU时间</h4>
<p>用户进程获得了CPU资源以后，在内核态的执行时间。</p>
<h3 id="3-block-time">3. Block Time</h3>
<h3 id="4-memery-allocation">4. Memery allocation</h3>
<h3 id="5-gc-timestime-spent">5. GC times/time spent</h3>
<h2 id="3-调优示例">3. 调优示例</h2>
<h3 id="1-源代码">1. 源代码</h3>
<h4 id="optmizationgo">optmization.go</h4>
<pre><code class="language-go">package profiling

import (
	&quot;encoding/json&quot;
	&quot;strconv&quot;
	&quot;strings&quot;
)

func createRequest() string {
	payload := make([]int, 100, 100)
	for i := 0; i &lt; 100; i++ {
		payload[i] = i
	}
	req := Request{&quot;demo_transaction&quot;, payload}
	v, err := json.Marshal(&amp;req)
	if err != nil {
		panic(err)
	}
	return string(v)
}

func processRequest(reqs []string) []string {
	reps := []string{}
	for _, req := range reqs {
		reqObj := &amp;Request{}
		reqObj.UnmarshalJSON([]byte(req))
		//	json.Unmarshal([]byte(req), reqObj)

		var buf strings.Builder
		for _, e := range reqObj.PayLoad {
			buf.WriteString(strconv.Itoa(e))
			buf.WriteString(&quot;,&quot;)
		}
		repObj := &amp;Response{reqObj.TransactionID, buf.String()}
		repJson, err := repObj.MarshalJSON()
		//repJson, err := json.Marshal(&amp;repObj)
		if err != nil {
			panic(err)
		}
		reps = append(reps, string(repJson))
	}
	return reps
}

</code></pre>
<h4 id="structsgo">structs.go</h4>
<pre><code class="language-go">package profiling

type Request struct {
	TransactionID string `json:&quot;transaction_id&quot;`
	PayLoad       []int  `json:&quot;payload&quot;`
}

type Response struct {
	TransactionID string `json:&quot;transaction_id&quot;`
	Expression    string `json:&quot;exp&quot;`
}

</code></pre>
<h4 id="structs_easyjsongo">structs_easyjson.go</h4>
<p>这段代码是自动生成的，不是手写的，用的是<a href="https://github.com/mailru/easyjson">easyjson</a>这个库，这个库的作用是反序列化json,比go lib中原始的json.Unmarshal要快很多。</p>
<pre><code class="language-go">// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package profiling

import (
	json &quot;encoding/json&quot;
	easyjson &quot;github.com/mailru/easyjson&quot;
	jlexer &quot;github.com/mailru/easyjson/jlexer&quot;
	jwriter &quot;github.com/mailru/easyjson/jwriter&quot;
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjson6a975c40DecodeCh47(in *jlexer.Lexer, out *Response) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case &quot;transaction_id&quot;:
			out.TransactionID = string(in.String())
		case &quot;exp&quot;:
			out.Expression = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson6a975c40EncodeCh47(out *jwriter.Writer, in Response) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = &quot;,\&quot;transaction_id\&quot;:&quot;
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.TransactionID))
	}
	{
		const prefix string = &quot;,\&quot;exp\&quot;:&quot;
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Expression))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Response) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson6a975c40EncodeCh47(&amp;w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Response) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson6a975c40EncodeCh47(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Response) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson6a975c40DecodeCh47(&amp;r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Response) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson6a975c40DecodeCh47(l, v)
}
func easyjson6a975c40DecodeCh471(in *jlexer.Lexer, out *Request) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case &quot;transaction_id&quot;:
			out.TransactionID = string(in.String())
		case &quot;payload&quot;:
			if in.IsNull() {
				in.Skip()
				out.PayLoad = nil
			} else {
				in.Delim('[')
				if out.PayLoad == nil {
					if !in.IsDelim(']') {
						out.PayLoad = make([]int, 0, 8)
					} else {
						out.PayLoad = []int{}
					}
				} else {
					out.PayLoad = (out.PayLoad)[:0]
				}
				for !in.IsDelim(']') {
					var v1 int
					v1 = int(in.Int())
					out.PayLoad = append(out.PayLoad, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson6a975c40EncodeCh471(out *jwriter.Writer, in Request) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = &quot;,\&quot;transaction_id\&quot;:&quot;
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.TransactionID))
	}
	{
		const prefix string = &quot;,\&quot;payload\&quot;:&quot;
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.PayLoad == nil &amp;&amp; (out.Flags&amp;jwriter.NilSliceAsEmpty) == 0 {
			out.RawString(&quot;null&quot;)
		} else {
			out.RawByte('[')
			for v2, v3 := range in.PayLoad {
				if v2 &gt; 0 {
					out.RawByte(',')
				}
				out.Int(int(v3))
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Request) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson6a975c40EncodeCh471(&amp;w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Request) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson6a975c40EncodeCh471(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Request) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson6a975c40DecodeCh471(&amp;r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Request) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson6a975c40DecodeCh471(l, v)
}

</code></pre>
<h4 id="optimization_testgo">optimization_test.go</h4>
<pre><code class="language-go">package profiling

import &quot;testing&quot;

func TestCreateRequest(t *testing.T) {
	str := createRequest()
	t.Log(str)
}

func TestProcessRequest(t *testing.T) {
	reqs := []string{}
	reqs = append(reqs, createRequest())
	reps := processRequest(reqs)
	t.Log(reps[0])
}

func BenchmarkProcessRequest(b *testing.B) {

	reqs := []string{}
	reqs = append(reqs, createRequest())
	b.ResetTimer()
	for i := 0; i &lt; b.N; i++ {
		_ = processRequest(reqs)
	}
	b.StopTimer()

}

</code></pre>
<p>以上的代码主要是对比使用easyjson与go原装的json.Unmarshal,使用性能调优工具直观的看出easyjson的性能更佳。</p>
<h3 id="2-调优步骤">2. 调优步骤</h3>
<h4 id="1-生成cpuprof文件">1. 生成cpu.prof文件</h4>
<pre><code class="language-shell">## benchmark不理解的在博客中寻找讲golang测试的章节，有队benchmark对一个介绍。
go test -bench=. -cpuprofile=cpu.prof
go test -bench=. -memprofile=mem.prof
</code></pre>
<h4 id="2-执行pprof调优">2. 执行pprof调优</h4>
<h5 id="1-cpu调优示例">1. cpu调优示例</h5>
<pre><code class="language-shell">go tool pprof cpu.prof
File: ch47.test
Type: cpu
Time: Aug 2, 2020 at 2:27pm (BST)
Duration: 1.41s, Total samples = 1.25s (88.59%)
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof) list processRequest
Total: 1.25s
ROUTINE ======================== go_learning/code/ch47.processRequest in /root/codes/go/src/go_learning/code/ch47/optmization.go
      30ms      1.04s (flat, cum) 83.20% of Total
         .          .     20:}
         .          .     21:
         .          .     22:func processRequest(reqs []string) []string {
         .          .     23:	reps := []string{}
         .          .     24:	for _, req := range reqs {
         .       10ms     25:		reqObj := &amp;Request{}
         .      140ms     26:		reqObj.UnmarshalJSON([]byte(req))
         .      320ms     27:		json.Unmarshal([]byte(req), reqObj)
         .          .     28:
         .          .     29:		var buf strings.Builder
         .          .     30:		var ret string
         .          .     31:		for _, e := range reqObj.PayLoad {
      20ms      290ms     32:			ret += strconv.Itoa(e) + &quot;,&quot;
         .       50ms     33:			buf.WriteString(strconv.Itoa(e))
         .          .     34:			buf.WriteString(&quot;,&quot;)
         .          .     35:		}
      10ms       30ms     36:		repObj := &amp;Response{reqObj.TransactionID, buf.String()}
         .          .     37:		repObj = &amp;Response{reqObj.TransactionID, ret}
         .       20ms     38:		repJson, err := repObj.MarshalJSON()
         .      160ms     39:		repJson, err = json.Marshal(&amp;repObj)
         .          .     40:		if err != nil {
         .          .     41:			panic(err)
         .          .     42:		}
         .       20ms     43:		reps = append(reps, string(repJson))
         .          .     44:	}
         .          .     45:	return reps
         .          .     46:}
</code></pre>
<p>从结果上来看可见processRequest 这个方法的CPU占用的总时间是1.26s ,其中占用时间最长的是<strong>json.Unmarshal([]byte(req), reqObj)</strong>，使用了680ms，这也是golang自己的官方lib中的方法json.Unmarshal，相较于上面的reqObj.UnmarshalJSON([]byte(req))用的时间（230ms），用easyJson去做反序列化，看出性能上是快了不少，几乎是两倍的差距。第二个占用较多cpu资源的就是<strong>ret += strconv.Itoa(e) + &quot;,&quot;</strong>，使用string直接拼接的方式确实是不赞同，尤其是在大量字符串拼接的场景下，对cpu和内存都是比较大的消耗，具体原因在下面的内存调优中会解释。</p>
<h5 id="2内存调优示例">2.内存调优示例</h5>
<pre><code class="language-go">go tool pprof mem.prof
File: ch47.test
Type: alloc_space
Time: Aug 2, 2020 at 2:13pm (BST)
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof) list processRequest
Total: 32.51MB
ROUTINE ======================== go_learning/code/ch47.processRequest in /root/codes/go/src/go_learning/code/ch47/optmization.go
   28.01MB    32.51MB (flat, cum)   100% of Total
         .          .     21:
         .          .     22:func processRequest(reqs []string) []string {
         .          .     23:	reps := []string{}
         .          .     24:	for _, req := range reqs {
         .          .     25:		reqObj := &amp;Request{}
       1MB     3.50MB     26:		reqObj.UnmarshalJSON([]byte(req))
    1.50MB     1.50MB     27:		json.Unmarshal([]byte(req), reqObj)
         .          .     28:
         .          .     29:		var buf strings.Builder
         .          .     30:		var ret string
         .          .     31:		for _, e := range reqObj.PayLoad {
   25.51MB    25.51MB     32:			ret += strconv.Itoa(e) + &quot;,&quot;
         .        1MB     33:			buf.WriteString(strconv.Itoa(e))
         .          .     34:			buf.WriteString(&quot;,&quot;)
         .          .     35:		}
         .          .     36:		repObj := &amp;Response{reqObj.TransactionID, buf.String()}
         .          .     37:		repObj = &amp;Response{reqObj.TransactionID, ret}
         .          .     38:		repJson, err := repObj.MarshalJSON()
         .        1MB     39:		repJson, err = json.Marshal(&amp;repObj)
         .          .     40:		if err != nil {
         .          .     41:			panic(err)
         .          .     42:		}
         .          .     43:		reps = append(reps, string(repJson))
         .          .     44:	}
</code></pre>
<p>从结果上看最消耗内存的是<strong>ret += strconv.Itoa(e) + &quot;,&quot;</strong>,这个要比较好理解，go的字符串拼接会消耗很大的内存，go的string底层其实是一个slice，熟悉go的slice原理的都知道，slice的append操作是要另寻一块连续的内存地址的，正因为要另开辟一块连续的内存空间才使内存消耗看起来如此巨大，这里采取的策略是使用buffer的WriteString方法，go的buffer的扩充方式有三种，这里不依依赘述了，以后我会开专栏去讲解的go的buffer，在这里只是提供了一种解决方案而已，本篇的核心思想是提现如何去调试你的代码的性能。</p>
<h2 id="4-总结">4. 总结</h2>
<p>性能调优其实是一门很大的学文，对于程序员本身来说要求比较高，除了熟练的掌握语言本身以外，还必须要有一定的经验，这样才能在调试中快速的定位问题以及处理问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang的Map并发性能以及原理分析]]></title>
        <id>https://ttlv.github.io/blog/post/golang-de-map-bing-fa-xing-neng-yi-ji-yuan-li-fen-xi/</id>
        <link href="https://ttlv.github.io/blog/post/golang-de-map-bing-fa-xing-neng-yi-ji-yuan-li-fen-xi/">
        </link>
        <updated>2021-01-17T14:44:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-golang-map数据类型的问题">1. golang map数据类型的问题</h2>
<p>在Go 1.6之前， 内置的map类型是部分goroutine安全的，并发的读没有问题，并发的写可能有问题。自go 1.6之后， 并发地读写map会报错，这在一些知名的开源库中都存在这个问题，所以go 1.9之前的解决方案是额外绑定一个锁，封装成一个新的struct或者单独使用锁都可以。</p>
<h2 id="2-map如何导致出现并发问题">2. map如何导致出现并发问题</h2>
<p>golang官方的faq已经提到build-in的map不是线程(goroutine)安全的。</p>
<p>现在就基于这个场景，构建出一段示例代码</p>
<pre><code class="language-go">package main
func main() {
	m := make(map[int]int)
	go func() {
		for {
			_ = m[1]
		}
	}()
	go func() {
		for {
			m[2] = 2
		}
	}()
	select {}
}
</code></pre>
<p>上述这段的代码的意思也很好理解，俩goroutine，第一个goroutine负责不停的读取m这个map对象，而第二个goroutine在不停地往m这个map对象中不停的写入同一个数据。最后我们来运行一下这段代码看一下结果</p>
<pre><code class="language-shell">go run main.go
fatal error: concurrent map read and map write
</code></pre>
<p>结果也是我们意料之中的事情，golang的build-in的map并不支持并发的读写操作。基于为什么会这样，这就和go的源码有关了，原因在于，在read的时候回去检查<strong>hashWriting</strong>标志，如果存在这个标志，就会出现并发错误。</p>
<p><a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map_fast.go">源码URL跳转链接</a></p>
<p>设置完之后又会取消<strong>hashWriting</strong>这个标识。源码中会检查是不是有并发的写，删除键的时候，遍历的时候并发读写的问题。map的并发问题不是那么容易被发现，可以利用-race来检查。</p>
<h2 id="3-go-19之前的解决方案">3. Go 1.9之前的解决方案</h2>
<p>很多时候我们会并发的使用mao对象，尤其是在一定的规模项目中，map总会保存goroutine共享的数据。go官方在那个时候给出了一个简单的解决方案。大家也肯定和官方想的一样，就是加锁。</p>
<pre><code class="language-go">var counter = struct{
    sync.RWMutex
    m map[string]int
}{m: make(map[string]int)}
</code></pre>
<p>设置一个struct，嵌入一个读写锁和一个map。</p>
<p>在读数据的时候加锁</p>
<pre><code class="language-go">counter.RLock()
n := counter.m[&quot;some_key&quot;]
counter.RUnlock()
fmt.Println(&quot;some_key:&quot;, n)
</code></pre>
<p>写入的时候也加锁</p>
<pre><code class="language-go">counter.Lock()
counter.m[&quot;some_key&quot;]++
counter.Unlock()
</code></pre>
<h2 id="4-现有的map并发安全的解决方案以及问题">4. 现有的map并发安全的解决方案以及问题</h2>
<table>
<thead>
<tr>
<th style="text-align:center">实现方式</th>
<th style="text-align:center"><strong>原理</strong></th>
<th style="text-align:center">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">map+Mutex</td>
<td style="text-align:center">通过Mutex互斥锁来实现多个goroutine对map的串行化访问</td>
<td style="text-align:center">读写都需要通过Mutex加锁和释放锁，适用于读写比接近的场景</td>
</tr>
<tr>
<td style="text-align:center">map+RWMutex</td>
<td style="text-align:center">通过RWMutex来实现对map的读写进行读写锁分离加锁，从而实现读的并发性能提高</td>
<td style="text-align:center">同Mutex相比适用于读多写少的场景</td>
</tr>
<tr>
<td style="text-align:center">sync.Map</td>
<td style="text-align:center">底层通分离读写map和原子指令来实现读的近似无锁，并通过延迟更新的方式来保证读的无锁化</td>
<td style="text-align:center">读多修改少，元素增加删除频率不高的情况，在大多数情况下替代上述两种实现</td>
</tr>
</tbody>
</table>
<h3 id="map的容量问题">map的容量问题</h3>
<figure data-type="image" tabindex="1"><img src="https://img2018.cnblogs.com/blog/1506724/201912/1506724-20191230011542055-246465627.png" alt="image.png" loading="lazy"></figure>
<p>在Mutex和RWMutex实现的并发安全的map中map随着时间和元素数量的增加、删除，容量会不断的递增，在某些情况下比如在某个时间点频繁的进行大量数据的增加，然后又大量的删除，其map的容量并不会随着元素的删除而缩小，而在sync.Map中，当进行元素从dirty进行提升到read map的时候会进行重建，可能会缩容</p>
<h2 id="5-sync-map">5. sync map</h2>
<h3 id="1-无锁读与读写分离">1. 无锁读与读写分离</h3>
<figure data-type="image" tabindex="2"><img src="https://img2018.cnblogs.com/blog/1506724/201912/1506724-20191230011542279-1556421363.png" alt="image.png" loading="lazy"></figure>
<h4 id="1-读写分离">1. 读写分离</h4>
<p>并发访问map读的主要问题其实是在扩容的时候，可能会导致元素被hash到其他的地址，那如果我的读的map不会进行扩容操作，就可以进行并发安全的访问了，而sync.map里面正是采用了这种方式，对增加元素通过dirty来进行保存</p>
<h4 id="2-无锁读">2. 无锁读</h4>
<p>通过read只读和dirty写map将操作分离，其实就只需要通过原子指令对read map来进行读操作而不需要加锁了，从而提高读的性能</p>
<h4 id="3-写加锁与延迟提升">3. 写加锁与延迟提升</h4>
<figure data-type="image" tabindex="3"><img src="https://img2018.cnblogs.com/blog/1506724/201912/1506724-20191230011542456-2036975558.png" alt="image.png" loading="lazy"></figure>
<h5 id="1-写加锁">1. 写加锁</h5>
<p>上面提到增加元素操作可能会先增加到dirty写map中，那针对多个goroutine同时写，其实就需要进行Mutex加锁了</p>
<h5 id="2-延迟提升">2. 延迟提升</h5>
<p>上面提到了read只读map和dirty写map, 那就会有个问题，默认增加元素都放在dirty中，那后续访问新的元素如果都通过 mutex加锁，那read只读map就失去意义，sync.Map中采用一直延迟提升的策略，进行批量将当前map中的所有元素都提升到read只读map中从而为后续的读访问提供无锁支持</p>
<h3 id="2-指针与惰性删除">2. 指针与惰性删除</h3>
<figure data-type="image" tabindex="4"><img src="https://img2018.cnblogs.com/blog/1506724/201912/1506724-20191230011542614-1139785696.png" alt="image.png" loading="lazy"></figure>
<h4 id="1-map里面的指针">1. map里面的指针</h4>
<p>map里面存储数据都会涉及到一个问题就是存储值还是指针，存储值可以让 map作为一个大的的对象，减轻垃圾回收的压力(避免扫描所有小对象)，而存储指针可以减少内存利用，而sync.Map中其实采用了指针结合惰性删除的方式，来进行 map的value的存储</p>
<h4 id="2-惰性删除">2. 惰性删除</h4>
<p>惰性删除是并发设计中一中常见的设计，比如删除某个个链表元素，如果要删除则需要修改前后元素的指针，而采用惰性删除，则通常只需要给某个标志位设定为删除，然后在后续修改中再进行操作，sync.Map中也采用这种方式，通过给指针指向某个标识删除的指针，从而实现惰性删除</p>
<h3 id="3-syncmap的特点">3.  sync.map的特点</h3>
<ul>
<li>空间换时间，通过冗余的两个数据结构（read，dirty）实现加锁对性能的影响。</li>
<li>使用只读锁，避免读写冲突。</li>
<li>动态调整，miss次数多了之后，将dirty数据提升为read。</li>
<li>double-checking。</li>
<li>延迟删除。删除一个key值只是打标记，只有在提升dirty的时候才清理的数据。</li>
<li>有限从read中读取，更新，删除，因为对read的读取都不需要锁。</li>
</ul>
<h3 id="4-源代码解析">4. 源代码解析</h3>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdn.net/20171216105435854?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmt1bmtpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" loading="lazy"></figure>
<h4 id="1-map">1. Map</h4>
<pre><code class="language-go">type Map struct {
	// 当涉及到dirty数据的操作的时候，需要使用这个锁
	mu Mutex
	// 一个只读的数据结构，因为只读，所以不会有读写冲突。
	// 所以从这个数据中读取总是安全的。
	// 实际上，实际也会更新这个数据的entries,如果entry是未删除的(unexpunged), 并不需要加锁。如果entry已经被删除了，需要加锁，以便更新dirty数据。
	read atomic.Value // readOnly
	// dirty数据包含当前的map包含的entries,它包含最新的entries(包括read中未删除的数据,虽有冗余，但是提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),有些数据还可能没有移动到read字段中。
	// 对于dirty的操作需要加锁，因为对它的操作可能会有读写竞争。
	// 当dirty为空的时候， 比如初始化或者刚提升完，下一次的写操作会复制read字段中未删除的数据到这个数据中。
	dirty map[interface{}]*entry
	// 当从Map中读取entry的时候，如果read中不包含这个entry,会尝试从dirty中读取，这个时候会将misses加一，
	// 当misses累积到 dirty的长度的时候， 就会将dirty提升为read,避免从dirty中miss太多次。因为操作dirty需要加锁。
	misses int
}
</code></pre>
<p>sync的Map的数据结构比较简单，只有四个字段，<code>read</code>、<code>mu</code>、<code>dirty</code>、<code>misses</code>。</p>
<p>它使用了冗余的数据结构<code>read</code>、<code>dirty</code>。<code>dirty</code>中会包含<code>read</code>中为删除的entries，新增加的entries会加入到<code>dirty</code>中。</p>
<h4 id="2-readonly">2. Readonly</h4>
<p><code>read</code>的数据结构是</p>
<pre><code class="language-go">type readOnly struct {
	m       map[interface{}]*entry
	amended bool // 如果Map.dirty有些数据不在其中的时候，这个值为true
}
</code></pre>
<p>只读map,对该map元素的访问不需要加锁，但是该map也不会进行元素的增加，元素会被先添加到dirty中然后后续再转移到read只读map中，通过atomic原子操作不需要进行锁操作。</p>
<p><code>amended</code>指明<code>Map.dirty</code>中有<code>readOnly.m</code>未包含的数据，所以如果从<code>Map.read</code>找不到数据的话，还要进一步到<code>Map.dirty</code>中查找。</p>
<p>对Map.read的修改是通过原子操作进行的。</p>
<p>虽然<code>read</code>和<code>dirty</code>有冗余数据，但这些数据是通过指针指向同一个数据，所以尽管Map的value会很大，但是冗余的空间占用还是有限的。</p>
<h4 id="3-entry">3. entry</h4>
<p><code>readOnly.m</code>和<code>Map.dirty</code>存储的值类型是<code>*entry</code>,它包含一个指针p, 指向用户存储的value值。</p>
<pre><code class="language-go">type entry struct {
	p unsafe.Pointer // *interface{}
}
</code></pre>
<p>entry是sync.Map中值得指针，如果当p指针指向expunged这个指针的时候，则表明该元素被删除，但不会立即从map中删除，如果在未删除之前又重新赋值则会重用该元素。</p>
<p>p的值</p>
<ul>
<li>nil: entry已被删除了，并且m.dirty为nil</li>
<li>expunged: entry已被删除了，并且m.dirty不为nil，而且这个entry不存在于m.dirty中</li>
<li>其它： entry是一个正常的值</li>
</ul>
<h4 id="4-read-map与dirty-map的关系">4. read map与dirty map的关系</h4>
<figure data-type="image" tabindex="6"><img src="https://picb.zhimg.com/80/v2-ab3818df87945f7b9dab93911bc02359_720w.jpg" alt="img" loading="lazy"></figure>
<p>从上图中可以看出，read map 和 dirty map 中含有相同的一部分 <code>entry</code>，我们称作是 normal entries，是双方共享的。状态就是上面所说的p的值<code>nil</code>和<code>unexpunged</code>。</p>
<p>但是 read map 中含有一部分 <code>entry</code> 是不属于 dirty map 的，而这部分 <code>entry</code> 就是状态为 <code>expunged</code> 状态的 <code>entry</code>。而 dirty map 中有一部分 <code>entry</code> 也是不属于 read map 的，而这部分其实是来自 <code>Store</code> 操作形成的（也就是新增的 <code>entry</code>），换句话说就是新增的 <code>entry</code> 是出现在 dirty map 中的。这句话其实在文中已经是重复了好几次了，还是要请大家记住这一点，只要是添加的，就一定是添加到dirty map中。</p>
<p>现在可以了解read map 和 dirty map 的是什么了，那么还得理解一个重要的问题是： read map 和 dirty map 是用来干什么的，以及为什么这么设计？</p>
<p>第一个问题比较好回答，read map 是用来进行 lock free 操作的（其实可以读写，但是不能做删除操作，因为一旦做了删除操作，就不是线程安全的了，也就无法 lock free），而 dirty map 是用来在无法进行 lock free 操作的情况下，需要 lock 来做一些更新工作的对象。下面我们重点看看<code>Load</code>、<code>Store</code>、<code>Delete</code>、<code>Range</code>这四个方法，其它辅助方法可以参考这四个方法来理解。</p>
<h4 id="5-load">5. Load</h4>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdn.net/20171216090402285?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmt1bmtpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" loading="lazy"></figure>
<p>加载方法，也就是提供一个键<code>key</code>,查找对应的值<code>value</code>,如果不存在，通过<code>ok</code>反映：</p>
<pre><code class="language-go">func (m *Map) Load(key interface{}) (value interface{}, ok bool) {
	// 1.首先从m.read中得到只读readOnly,从它的map中查找，不需要加锁
	read, _ := m.read.Load().(readOnly)
	e, ok := read.m[key]
	// 2. 如果没找到，并且m.dirty中有新数据，需要从m.dirty查找，这个时候需要加锁
	if !ok &amp;&amp; read.amended {
		m.mu.Lock()
		// 双检查，避免加锁的时候m.dirty提升为m.read,这个时候m.read可能被替换了。
		read, _ = m.read.Load().(readOnly)
		e, ok = read.m[key]
		// 如果m.read中还是不存在，并且m.dirty中有新数据
		if !ok &amp;&amp; read.amended {
			// 从m.dirty查找
			e, ok = m.dirty[key]
			// 不管m.dirty中存不存在，都将misses计数加一
			// missLocked()中满足条件后就会提升m.dirty
			m.missLocked()
		}
		m.mu.Unlock()
	}
	if !ok {
		return nil, false
	}
	return e.load()
}
</code></pre>
<p>这里有两个值的关注的地方。一个是首先从<code>m.read</code>中加载，不存在的情况下，并且<code>m.dirty</code>中有新数据，加锁，然后从<code>m.dirty</code>中加载。</p>
<p>二是这里使用了双检查的处理，因为在下面的两个语句中，这两行语句并不是一个原子操作</p>
<pre><code class="language-go">if !ok &amp;&amp; read.amended {
		m.mu.Lock()
		}
</code></pre>
<p>虽然第一句执行的时候条件满足，但是在加锁之前，<code>m.dirty</code>可能被提升为<code>m.read</code>,所以加锁后还得再检查<code>m.read</code>，后续的方法中都使用了这个方法。</p>
<p>双检查的技术Java程序员非常熟悉了，单例模式的实现之一就是利用双检查的技术。</p>
<p>可以看到，如果我们查询的键值正好存在于<code>m.read</code>中，无须加锁，直接返回，理论上性能优异。即使不存在于<code>m.read</code>中，经过<code>miss</code>几次之后，<code>m.dirty</code>会被提升为<code>m.read</code>，又会从<code>m.read</code>中查找。所以对于更新／增加比较少的场景，加载存在的key很多的case,性能基本和无锁的map类似。</p>
<p>下面看看<code>m.dirty</code>是如何被提升为m.read的。 <code>missLocked</code>方法中可能会将<code>m.dirty</code>提升。</p>
<h5 id="dirty到read-map的迁移">dirty到read map的迁移</h5>
<p>Load的源码中有一个函数叫missLocked，这个函数比较重要，是关系dirty到read map迁移操作的，对着源码着重说一说。</p>
<figure data-type="image" tabindex="8"><img src="https://img2018.cnblogs.com/blog/1506724/201912/1506724-20191230011543227-487439535.png" alt="image.png" loading="lazy"></figure>
<pre><code class="language-go">func (m *Map) missLocked() {
	m.misses++
	if m.misses &lt; len(m.dirty) {
		return
	}
	m.read.Store(readOnly{m: m.dirty})
	m.dirty = nil
	m.misses = 0
}
</code></pre>
<p>上面的最后三行代码就是提升<code>m.dirty</code>的，很简单的将<code>m.dirty</code>作为<code>readOnly</code>的<code>m</code>字段，原子更新<code>m.read</code>。提升后<code>m.dirty</code>、<code>m.misses</code>重置， 并且<code>m.read.amended</code>为false。这种做法无疑是会提升read map的命中率。</p>
<p>当持续的从read访问穿透到dirty中后，就会触发一次从dirty到read的迁移，这也意味着如果我们的元素读写比差比较小，其实就会导致频繁的迁移操作，性能其实可能并不如rwmutex等实现。</p>
<h4 id="6-store">6. store</h4>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdn.net/20171215190936827?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmt1bmtpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" loading="lazy"></figure>
<p>这个方法是更新或者新增一个entry。</p>
<pre><code class="language-go">func (m *Map) Store(key, value interface{}) {
	// 如果m.read存在这个键，并且这个entry没有被标记删除，尝试直接存储。
	// 因为m.dirty也指向这个entry,所以m.dirty也保持最新的entry。
	read, _ := m.read.Load().(readOnly)
	if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {
		return
	}
	// 如果`m.read`不存在或者已经被标记删除
	m.mu.Lock()
	read, _ = m.read.Load().(readOnly)
	if e, ok := read.m[key]; ok {
		if e.unexpungeLocked() { //标记成未被删除
			m.dirty[key] = e //m.dirty中不存在这个键，所以加入m.dirty
		}
		e.storeLocked(&amp;value) //更新
	} else if e, ok := m.dirty[key]; ok { // m.dirty存在这个键，更新
		e.storeLocked(&amp;value)
	} else { //新键值
		if !read.amended { //m.dirty中没有新的数据，往m.dirty中增加第一个新键
			m.dirtyLocked() //从m.read中复制未删除的数据
			m.read.Store(readOnly{m: read.m, amended: true})
		}
		m.dirty[key] = newEntry(value) //将这个entry加入到m.dirty中
	}
	m.mu.Unlock()
}
// 在刚初始化和将所有元素迁移到read中后，dirty默认都是nil元素，而此时如果有新的元素增加，则需要先将read map中的所有未删除数据先迁移到dirty中
func (m *Map) dirtyLocked() {
	if m.dirty != nil {
		return
	}
	read, _ := m.read.Load().(readOnly)
	m.dirty = make(map[interface{}]*entry, len(read.m))
	for k, e := range read.m {
		if !e.tryExpungeLocked() {
			m.dirty[k] = e
		}
	}
}
func (e *entry) tryExpungeLocked() (isExpunged bool) {
	p := atomic.LoadPointer(&amp;e.p)
	for p == nil {
		// 将已经删除标记为nil的数据标记为expunged
		if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) {
			return true
		}
		p = atomic.LoadPointer(&amp;e.p)
	}
	return p == expunged
}
</code></pre>
<p>你可以看到，以上操作都是先从操作<code>m.read</code>开始的，不满足条件再加锁，然后操作<code>m.dirty</code>。</p>
<p><code>Store</code>可能会在某种情况下(初始化或者m.dirty刚被提升后)从<code>m.read</code>中复制数据，如果这个时候<code>m.read</code>中数据量非常大，可能会影响性能。</p>
<h5 id="read-map到dirty-map的迁移">read map到dirty map的迁移</h5>
<p>着重的讲一下源码中的dirtyLocked函数</p>
<p>在刚初始化和将所有元素迁移到read中后，dirty默认都是nil元素，而此时如果有新的元素增加，则需要先将read map中的所有未删除数据先迁移到dirty中。</p>
<figure data-type="image" tabindex="10"><img src="https://img2018.cnblogs.com/blog/1506724/201912/1506724-20191230011543035-1097819548.png" alt="image.png" loading="lazy"></figure>
<pre><code class="language-go">func (m *Map) dirtyLocked() {
    if m.dirty != nil {
        return
    }

    read, _ := m.read.Load().(readOnly)
    m.dirty = make(map[interface{}]*entry, len(read.m))
    for k, e := range read.m {
        if !e.tryExpungeLocked() {
            m.dirty[k] = e
        }
    }
}
</code></pre>
<h4 id="7-delete">7. Delete</h4>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdn.net/20171216092834586?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmt1bmtpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" loading="lazy"></figure>
<p>删除一个键值。</p>
<pre><code class="language-go">func (m *Map) Delete(key interface{}) {
	read, _ := m.read.Load().(readOnly)
	e, ok := read.m[key]
	if !ok &amp;&amp; read.amended {
		m.mu.Lock()
		read, _ = m.read.Load().(readOnly)
		e, ok = read.m[key]
		if !ok &amp;&amp; read.amended {
			delete(m.dirty, key)
		}
		m.mu.Unlock()
	}
	if ok {
		e.delete()
	}
}
</code></pre>
<p>同样，删除操作还是从<code>m.read</code>中开始， 如果这个entry不存在于<code>m.read</code>中，并且<code>m.dirty</code>中有新数据，则加锁尝试从<code>m.dirty</code>中删除。</p>
<p>注意，还是要双检查的。 从<code>m.dirty</code>中直接删除即可，就当它没存在过，但是如果是从<code>m.read</code>中删除，并不会直接删除，而是打标记：</p>
<pre><code class="language-go">func (e *entry) delete() (hadValue bool) {
	for {
		p := atomic.LoadPointer(&amp;e.p)
		// 已标记为删除
		if p == nil || p == expunged {
			return false
		}
		// 原子操作，e.p标记为nil
		if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {
			return true
		}
	}
}
</code></pre>
<p>这里有一个比较有意思的地方，原子操作e.p标记为nil而不是expunged，其中的原因是啥，我也仔细的想了一想，在开篇的时候我给了一张read map和dirty map关系的图，unexpunged的entry是readmap有而dirtymap中没有的，而这个值执行CAS条件表明<code>entry</code> 既不是 <code>nil</code> 也不是 <code>expunged</code> 的，那么就是说这个 <code>entry</code> 必定是存在于 dirty map 中的，也就不能置成 <code>expunged</code>。</p>
<h4 id="8-range">8. Range</h4>
<p>因为<code>for ... range map</code>是内建的语言特性，所以没有办法使用<code>for range</code>遍历<code>sync.Map</code>, 但是可以使用它的<code>Range</code>方法，通过回调的方式遍历。</p>
<pre><code class="language-go">func (m *Map) Range(f func(key, value interface{}) bool) {
	read, _ := m.read.Load().(readOnly)
	// 如果m.dirty中有新数据，则提升m.dirty,然后在遍历
	if read.amended {
		//提升m.dirty
		m.mu.Lock()
		read, _ = m.read.Load().(readOnly) //双检查
		if read.amended {
			read = readOnly{m: m.dirty}
			m.read.Store(read)
			m.dirty = nil
			m.misses = 0
		}
		m.mu.Unlock()
	}
	// 遍历, for range是安全的
	for k, e := range read.m {
		v, ok := e.load()
		if !ok {
			continue
		}
		if !f(k, v) {
			break
		}
	}
}
</code></pre>
<h4 id="9-load-store-delete">9. Load Store Delete</h4>
<p><code>Load Store Delete</code> 的操作都基本描述完了，可以用下面的一张图用来总结一下：</p>
<figure data-type="image" tabindex="12"><img src="https://pic2.zhimg.com/80/v2-264fe04200047fc89ccffa81d0c12620_720w.jpg" alt="img" loading="lazy"></figure>
<h2 id="6-read-map-和-dirty-map-的设计分析">6. read map 和 dirty map 的设计分析</h2>
<p>最核心和最基本的原因就是： 通过分离出 readonly 的部分，从而可以形成 lock free 的优化。</p>
<p>从上面的流程可以发现，对于 read map 中 <code>entry</code> 的操作是不需要 lock 的，但是为什么就能够保证这样的无锁操作是 thread-safe 的呢？</p>
<p>这是因为 read map 是 read-only 的，不过这里的 read-only 是指 entry 不会被删除，其实值是可以被更新，而值的更新是可以通过 CAS 操作保证 thread-safe 的，所以读者可以发现，即使在持有 lock 的时候，仍然需要 CAS 来对 read map 中的 <code>entry</code> 进行操作，此外对于 read map 本身的更新也是 通过 atomic 来操作的（在 <code>missLocked</code> 方法中）。</p>
<h2 id="7-syncmap-的缺陷">7 syncmap 的缺陷</h2>
<p>其实通过上面的分析，了解了整个流程的话，读者会很容易理解这个 syncmap 的缺点：当需要不停地新增和删除的时候，会导致 dirty map 不停地更新，甚至在 miss 过多之后，导致 dirty 成为 nil，并进入重建的过程</p>
<h2 id="8-关于-lock-free-的启发">8. 关于 lock free 的启发</h2>
<p>lock free 会给并发的性能带了较高的提升，目前通过 syncmap 的代码分析，我们也对 lock free 有一些了解，下面会记录一下笔者从 syncmap 中得到的对 lock free 的一些理解。</p>
<h2 id="9-benchmark测试用数据说话">9. BenchMark测试，用数据说话</h2>
<h3 id="1-map无锁并发读与map有锁并发读的性能差异">1. map无锁并发读与map有锁并发读的性能差异</h3>
<pre><code class="language-go">package lock_test

import (
	&quot;fmt&quot;
	&quot;sync&quot;
	&quot;testing&quot;
)

var cache map[string]string

const NUM_OF_READER int = 40
const READ_TIMES = 100000

func init() {
	cache = make(map[string]string)

	cache[&quot;a&quot;] = &quot;aa&quot;
	cache[&quot;b&quot;] = &quot;bb&quot;
}

func lockFreeAccess() {

	var wg sync.WaitGroup
	wg.Add(NUM_OF_READER)
	for i := 0; i &lt; NUM_OF_READER; i++ {
		go func() {
			for j := 0; j &lt; READ_TIMES; j++ {
				_, err := cache[&quot;a&quot;]
				if !err {
					fmt.Println(&quot;Nothing&quot;)
				}
			}
			wg.Done()
		}()
	}
	wg.Wait()
}

func lockAccess() {

	var wg sync.WaitGroup
	wg.Add(NUM_OF_READER)
	m := new(sync.RWMutex)
	for i := 0; i &lt; NUM_OF_READER; i++ {
		go func() {
			for j := 0; j &lt; READ_TIMES; j++ {

				m.RLock()
				_, err := cache[&quot;a&quot;]
				if !err {
					fmt.Println(&quot;Nothing&quot;)
				}
				m.RUnlock()
			}
			wg.Done()
		}()
	}
	wg.Wait()
}

func BenchmarkLockFree(b *testing.B) {
	b.ResetTimer()
	for i := 0; i &lt; b.N; i++ {
		lockFreeAccess()
	}
}

func BenchmarkLock(b *testing.B) {
	b.ResetTimer()
	for i := 0; i &lt; b.N; i++ {
		lockAccess()
	}
}

</code></pre>
<p>上面的代码比较简单，BenchMark测试的就是俩函数，一个是lockFreeAccess，一个是lockAccess，这两个函数的区别就是lockFreeAccess是无锁的，lockAccess还是带锁的。</p>
<pre><code class="language-shell">go test -bench=.
goos: darwin
goarch: amd64
pkg: go_learning/code/ch48/lock
BenchmarkLockFree-4   	     100	  12014281 ns/op
BenchmarkLock-4       	       6	 199626870 ns/op
PASS
ok  	go_learning/code/ch48/lock	3.245s
</code></pre>
<p>执行go test -bench=. 很明显的看出BenchmarkLockFree和BenchmarkLock，BenchmarkLockFree-4每次执行耗时是12014281纳秒，而BenchmarkLock-4 是199626870纳秒，两者明显就是相差了一个量级。</p>
<h4 id="cpu差异">cpu差异</h4>
<pre><code class="language-shell">go test -bench=. -cpuprofile=cpu.prof
go tool pprof cpu.prof
Type: cpu
Time: Aug 10, 2020 at 2:27am (GMT)
Duration: 2.76s, Total samples = 6.62s (240.26%)
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof) top
Showing nodes accounting for 6.49s, 98.04% of 6.62s total
Dropped 8 nodes (cum &lt;= 0.03s)
Showing top 10 nodes out of 34
      flat  flat%   sum%        cum   cum%
     1.57s 23.72% 23.72%      1.58s 23.87%  sync.(*RWMutex).RLock (inline)
     1.46s 22.05% 45.77%      1.47s 22.21%  sync.(*RWMutex).RUnlock (inline)
     1.40s 21.15% 66.92%      1.82s 27.49%  runtime.mapaccess2_faststr
     0.80s 12.08% 79.00%      0.80s 12.08%  runtime.findnull
     0.51s  7.70% 86.71%      2.07s 31.27%  go_learning/code/ch48/lock_test.lockFreeAccess.func1
     0.28s  4.23% 90.94%      0.28s  4.23%  runtime.pthread_cond_wait
     0.16s  2.42% 93.35%      0.16s  2.42%  runtime.newstack
     0.15s  2.27% 95.62%      0.15s  2.27%  runtime.add (partial-inline)
     0.11s  1.66% 97.28%      0.13s  1.96%  runtime.(*bmap).keys (inline)
     0.05s  0.76% 98.04%      3.40s 51.36%  go_learning/code/ch48/lock_test.lockAccess.func1
</code></pre>
<p>很明显 lockAccess的cpu耗时3.40s,而lockFreeAccess的cpu耗时是2.07s。</p>
<h3 id="2-对比concurrenthashmap">2. 对比ConcurrentHashMap</h3>
<p>如果熟悉Java的同学，可以对比一下java的<code>ConcurrentHashMap</code>的实现，在map的数据非常大的情况下，一把锁会导致大并发的客户端共争一把锁，Java的解决方案是<code>shard</code>, 内部使用多个锁，每个区间共享一把锁，这样减少了数据共享一把锁带来的性能影响。go的官方虽然没有提供类似Java的<code>ConcurrentHashMap</code>的实现，但是我也还是试着去尝试了下。</p>
<h4 id="1-concurrent_map_benchmark_adaptergo">1. concurrent_map_benchmark_adapter.go</h4>
<pre><code class="language-go">package maps

import &quot;github.com/easierway/concurrent_map&quot;

type ConcurrentMapBenchmarkAdapter struct {
	cm *concurrent_map.ConcurrentMap
}

func (m *ConcurrentMapBenchmarkAdapter) Set(key interface{}, value interface{}) {
	m.cm.Set(concurrent_map.StrKey(key.(string)), value)
}

func (m *ConcurrentMapBenchmarkAdapter) Get(key interface{}) (interface{}, bool) {
	return m.cm.Get(concurrent_map.StrKey(key.(string)))
}

func (m *ConcurrentMapBenchmarkAdapter) Del(key interface{}) {
	m.cm.Del(concurrent_map.StrKey(key.(string)))
}

func CreateConcurrentMapBenchmarkAdapter(numOfPartitions int) *ConcurrentMapBenchmarkAdapter {
	conMap := concurrent_map.CreateConcurrentMap(numOfPartitions)
	return &amp;ConcurrentMapBenchmarkAdapter{conMap}
}

</code></pre>
<h4 id="2-map_benchmark_testgo">2. map_benchmark_test.go</h4>
<pre><code class="language-go">package maps

import (
	&quot;strconv&quot;
	&quot;sync&quot;
	&quot;testing&quot;
)

const (
	NumOfReader = 100
	NumOfWriter = 10
)

type Map interface {
	Set(key interface{}, val interface{})
	Get(key interface{}) (interface{}, bool)
	Del(key interface{})
}

func benchmarkMap(b *testing.B, hm Map) {
	for i := 0; i &lt; b.N; i++ {
		var wg sync.WaitGroup
		for i := 0; i &lt; NumOfWriter; i++ {
			wg.Add(1)
			go func() {
				for i := 0; i &lt; 100; i++ {
					hm.Set(strconv.Itoa(i), i*i)
					hm.Set(strconv.Itoa(i), i*i)
					hm.Del(strconv.Itoa(i))
				}
				wg.Done()
			}()
		}
		for i := 0; i &lt; NumOfReader; i++ {
			wg.Add(1)
			go func() {
				for i := 0; i &lt; 100; i++ {
					hm.Get(strconv.Itoa(i))
				}
				wg.Done()
			}()
		}
		wg.Wait()
	}
}

func BenchmarkSyncmap(b *testing.B) {
	b.Run(&quot;map with RWLock&quot;, func(b *testing.B) {
		hm := CreateRWLockMap()
		benchmarkMap(b, hm)
	})

	b.Run(&quot;sync.map&quot;, func(b *testing.B) {
		hm := CreateSyncMapBenchmarkAdapter()
		benchmarkMap(b, hm)
	})

	b.Run(&quot;concurrent map&quot;, func(b *testing.B) {
		superman := CreateConcurrentMapBenchmarkAdapter(199)
		benchmarkMap(b, superman)
	})
}

</code></pre>
<h4 id="3-rw_mapgo">3. rw_map.go</h4>
<pre><code class="language-go">package maps

import &quot;sync&quot;

type RWLockMap struct {
	m    map[interface{}]interface{}
	lock sync.RWMutex
}

func (m *RWLockMap) Get(key interface{}) (interface{}, bool) {
	m.lock.RLock()
	v, ok := m.m[key]
	m.lock.RUnlock()
	return v, ok
}

func (m *RWLockMap) Set(key interface{}, value interface{}) {
	m.lock.Lock()
	m.m[key] = value
	m.lock.Unlock()
}

func (m *RWLockMap) Del(key interface{}) {
	m.lock.Lock()
	delete(m.m, key)
	m.lock.Unlock()
}

func CreateRWLockMap() *RWLockMap {
	m := make(map[interface{}]interface{}, 0)
	return &amp;RWLockMap{m: m}
}

</code></pre>
<h4 id="4-sync_map_benchmark_adaptergo">4. sync_map_benchmark_adapter.go</h4>
<pre><code class="language-go">package maps

import &quot;sync&quot;

func CreateSyncMapBenchmarkAdapter() *SyncMapBenchmarkAdapter {
	return &amp;SyncMapBenchmarkAdapter{}
}

type SyncMapBenchmarkAdapter struct {
	m sync.Map
}

func (m *SyncMapBenchmarkAdapter) Set(key interface{}, val interface{}) {
	m.m.Store(key, val)
}

func (m *SyncMapBenchmarkAdapter) Get(key interface{}) (interface{}, bool) {
	return m.m.Load(key)
}

func (m *SyncMapBenchmarkAdapter) Del(key interface{}) {
	m.m.Delete(key)
}

</code></pre>
<h5 id="1-读写量级一致相差不多">1 . 读写量级一致，相差不多</h5>
<p>benchmarkMap设置的是100次写和100次读</p>
<pre><code>go test -bench=.
goos: darwin
goarch: amd64
pkg: go_learning/code/ch48/maps
BenchmarkSyncmap/map_with_RWLock-4         	     398	   2780087 ns/op
BenchmarkSyncmap/sync.map-4                	     530	   2173851 ns/op
BenchmarkSyncmap/concurrent_map-4          	     693	   1505866 ns/op
PASS
ok  	go_learning/code/ch48/maps	4.709s
</code></pre>
<p>从结果上看基于Java的<code>ConcurrentHashMap</code>的性能更优异，其次是go的sync.map最后才是RWLock.</p>
<h5 id="2-读多写少">2. 读多写少</h5>
<p>benchmarkMap设置的是10次写和100次读</p>
<pre><code class="language-shell">go test -bench=.
goos: darwin
goarch: amd64
pkg: go_learning/code/ch48/maps
BenchmarkSyncmap/map_with_RWLock-4         	     630	   1644799 ns/op
BenchmarkSyncmap/sync.map-4                	    2103	    588642 ns/op
BenchmarkSyncmap/concurrent_map-4          	    1088	   1140983 ns/op
PASS
ok  	go_learning/code/ch48/maps	6.286s
</code></pre>
<p>从结果上看go的sync.map的性能高于其他两个不是一点点，所以对于并发操作读多写少的情况下，sync.map是嘴合适的选择。</p>
<h5 id="3-读少写多">3. 读少写多</h5>
<p>benchmarkMap设置的是100次写和10次读</p>
<pre><code>go test -bench=.
goos: darwin
goarch: amd64
pkg: go_learning/code/ch48/maps
BenchmarkSyncmap/map_with_RWLock-4         	     788	   1369344 ns/op
BenchmarkSyncmap/sync.map-4                	     650	   1744666 ns/op
BenchmarkSyncmap/concurrent_map-4          	    2065	    577972 ns/op
PASS
ok  	go_learning/code/ch48/maps	5.288s
</code></pre>
<p>从结果上看基于Java的<code>ConcurrentHashMap</code>的性能更优异，其次是RWLock最后才是sync.map.为什么sync.map会这么慢，在上面的分析中都有说明。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OhMyZsh基础配置]]></title>
        <id>https://ttlv.github.io/blog/post/ohmyzsh-ji-chu-pei-zhi/</id>
        <link href="https://ttlv.github.io/blog/post/ohmyzsh-ji-chu-pei-zhi/">
        </link>
        <updated>2021-01-17T14:43:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-安装zsh">1. 安装zsh</h2>
<p>shell的终端是遭不住，还是决定换成oh-my-zsh。</p>
<h3 id="1-查看当前shell">1. 查看当前shell</h3>
<pre><code class="language-shell">echo $SHELL
/bin/bash
</code></pre>
<h3 id="2-安装zsh">2. 安装zsh</h3>
<pre><code class="language-shell">apt install -y zsh // ubuntu或者是树莓派
yum install -y zsh // centos
brew install zsh // MACOSX,homebrew没有安装的去百度下咋装，这里就不展开说了 - -
</code></pre>
<h3 id="3-把zsh设置成默认shell">3. 把zsh设置成默认shell</h3>
<pre><code class="language-shell">chsh -s /bin/zsh
</code></pre>
<h3 id="4-安装git">4. 安装git</h3>
<pre><code class="language-shell">apt install -y git // ubuntu或者是树莓派
yum install -y git // centos
brew install git // MACOSX
</code></pre>
<h3 id="5-安装oh-my-zsh">5. 安装oh-my-zsh</h3>
<h4 id="1-自动安装">1. 自动安装</h4>
<pre><code class="language-shell">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;
</code></pre>
<h4 id="2-手动安装">2. 手动安装</h4>
<h5 id="1-下载源码">1. 下载源码</h5>
<pre><code class="language-shell">git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
</code></pre>
<h5 id="2-复制配置">2. 复制配置</h5>
<pre><code class="language-shell">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc
</code></pre>
<h3 id="6-生效配置">6. 生效配置</h3>
<pre><code class="language-shell">source .zshrc
</code></pre>
<h2 id="2-zshrc配置">2.  .zshrc配置</h2>
<pre><code class="language-shell"># If you come from bash you might have to change your $PATH.
# export PATH=$HOME/bin:/usr/local/bin:$PATH

# Path to your oh-my-zsh installation.
export ZSH=$HOME/.oh-my-zsh

# Set name of the theme to load --- if set to &quot;random&quot;, it will
# load a random theme each time oh-my-zsh is loaded, in which case,
# to know which specific one was loaded, run: echo $RANDOM_THEME
# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
ZSH_THEME=&quot;af-magic&quot;

# Set list of themes to pick from when loading at random
# Setting this variable when ZSH_THEME=random will cause zsh to load
# a theme from this variable instead of looking in $ZSH/themes/
# If set to an empty array, this variable will have no effect.
# ZSH_THEME_RANDOM_CANDIDATES=( &quot;robbyrussell&quot; &quot;agnoster&quot; )

# Uncomment the following line to use case-sensitive completion.
# CASE_SENSITIVE=&quot;true&quot;

# Uncomment the following line to use hyphen-insensitive completion.
# Case-sensitive completion must be off. _ and - will be interchangeable.
# HYPHEN_INSENSITIVE=&quot;true&quot;

# Uncomment the following line to disable bi-weekly auto-update checks.
# DISABLE_AUTO_UPDATE=&quot;true&quot;

# Uncomment the following line to automatically update without prompting.
# DISABLE_UPDATE_PROMPT=&quot;true&quot;

# Uncomment the following line to change how often to auto-update (in days).
# export UPDATE_ZSH_DAYS=13

# Uncomment the following line if pasting URLs and other text is messed up.
# DISABLE_MAGIC_FUNCTIONS=&quot;true&quot;

# Uncomment the following line to disable colors in ls.
# DISABLE_LS_COLORS=&quot;true&quot;

# Uncomment the following line to disable auto-setting terminal title.
# DISABLE_AUTO_TITLE=&quot;true&quot;

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION=&quot;true&quot;

# Uncomment the following line to display red dots whilst waiting for completion.
# COMPLETION_WAITING_DOTS=&quot;true&quot;

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY=&quot;true&quot;

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# You can set one of the optional three formats:
# &quot;mm/dd/yyyy&quot;|&quot;dd.mm.yyyy&quot;|&quot;yyyy-mm-dd&quot;
# or set a custom format using the strftime function format specifications,
# see 'man strftime' for details.
# HIST_STAMPS=&quot;mm/dd/yyyy&quot;

# Would you like to use another custom folder than $ZSH/custom?
# ZSH_CUSTOM=/path/to/new-custom-folder

# Which plugins would you like to load?
# Standard plugins can be found in $ZSH/plugins/
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(zsh-autosuggestions zsh-syntax-highlighting git)

source $ZSH/oh-my-zsh.sh

# User configuration

# export MANPATH=&quot;/usr/local/man:$MANPATH&quot;

# You may need to manually set your language environment
# export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR='vim'
# else
#   export EDITOR='mvim'
# fi

# Compilation flags
# export ARCHFLAGS=&quot;-arch x86_64&quot;

# Set personal aliases, overriding those provided by oh-my-zsh libs,
# plugins, and themes. Aliases can be placed here, though oh-my-zsh
# users are encouraged to define aliases within the ZSH_CUSTOM folder.
# For a full list of active aliases, run `alias`.
#
# Example aliases
# alias zshconfig=&quot;mate ~/.zshrc&quot;
# alias ohmyzsh=&quot;mate ~/.oh-my-zsh&quot;
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=&quot;fg=#ff00ff,bg=cyan,bold,underline&quot;

#git
alias gadd='git add'
alias gco='git checkout'
alias gm='git merge'
alias ts='tig status'
alias gb='git branch'
alias gpull='git pull --rebase'
alias gup='git pull --rebase'
alias gpush='git push origin master'
alias glo='git pull origin'
alias gso='git push origin'
alias grsh='git reset --soft HEAD\^'
alias gcm='git commit -m'
alias gs='git stash'
alias gsp='git stash pop'
alias gsas='git stash apply stash@'
alias gp='git push'
alias t='tig'
alias gsc='git stash clear'
alias mp='make push'

# go command
alias gtr='go test --run'
alias gt='go test'
alias gr='go run'
alias gg='go get -v -d -t'

#kubectl
alias k='kubectl'
alias kdp='k delete po'
alias kgp='k get po'
alias kdpa='k delete po --all'
alias kdesp='k describe po'
alias kgn='k get no'
alias klf='k logs -f'
alias ke='k exec -it'
alias kgns='k get ns'
alias kgpnd='k get po -n default'
alias kgpn='k get po -n'
alias kdp='k describe pod'
# docker
alias d='docker'
alias dpa='d ps -a'
alias di='d images'
alias dr='d rm'
alias dri='d rmi'
alias dlf='d logs -f'
alias de='d exec -it'
alias ds='d stop'
alias drm='d rm'
alias drmi='docker rmi'
</code></pre>
<p>这一份是我自己现在在使用的.zshrc配置,你们也可以拿去做参考,我手动安装了两个插件，用于补全的，比较好用，给大家推荐一下。</p>
<h3 id="1-安装zsh-autosuggestions">1. 安装zsh-autosuggestions</h3>
<h4 id="1-下载">1. 下载</h4>
<pre><code class="language-shell">git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
</code></pre>
<h4 id="2-在zshrc配置">2. 在.zshrc配置</h4>
<pre><code class="language-shell">plugins=(zsh-autosuggestions)
</code></pre>
<h4 id="3-带有颜色">3. 带有颜色</h4>
<p>在.zshrc中添加</p>
<pre><code>ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=&quot;fg=#ff00ff,bg=cyan,bold,underline&quot;
</code></pre>
<h3 id="2-安装zsh-syntax-highlighting">2. 安装zsh-syntax-highlighting</h3>
<pre><code class="language-shell">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git
echo &quot;source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; ${ZDOTDIR:-$HOME}/.zshrc
</code></pre>
<h4 id="2-在zshrc配置-2">2. 在.zshrc配置</h4>
<pre><code class="language-shell">plugins=(zsh-syntax-highlighting)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树莓派网络配置基础]]></title>
        <id>https://ttlv.github.io/blog/post/shu-mei-pai-wang-luo-pei-zhi-ji-chu/</id>
        <link href="https://ttlv.github.io/blog/post/shu-mei-pai-wang-luo-pei-zhi-ji-chu/">
        </link>
        <updated>2021-01-17T14:41:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-唤醒ssh服务">1. 唤醒SSH服务</h2>
<p>此方式默认已经将系统烧录到树莓派中，2016-11 官方发布的 Raspbian 系统镜像，系统默认禁用了 SSH 服务。要重新开启SSH服务也很方便，把SD卡拔下来，进入到根目录，新建一个名为<code>ssh</code>的文件。</p>
<h2 id="2-接入wifi">2. 接入WIFI</h2>
<h3 id="1-手动创建wpa_supplicantconf">1. 手动创建wpa_supplicant.conf</h3>
<pre><code class="language-shell">vim wpa_supplicant.conf
# /boot/wpa_supplicant.conf
country=US
// 这里需要注意一点，country如果改成是CN无法连入5G的WIFI。
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
    ssid=&quot;xxx&quot; // 配置WiFi名
    psk=&quot;xxxx&quot; // WiFi的密码
    priority=1
}
</code></pre>
<p>拔下SD卡，把vim wpa_supplicant.conf文件拖到根目录下面。</p>
<h3 id="2-命令行搜索wifi">2. 命令行搜索WiFi</h3>
<pre><code class="language-shell">iwlist scan
</code></pre>
<p>在终端执行该指令可以看到所有被树莓派搜索到的WiFi。</p>
<pre><code class="language-shell">vim /etc/wpa_supplicant/wpa_supplicant.conf
</code></pre>
<p>该操作和上面在手动创建wpa_supplicant.conf的操作一样，也是修改ssid和psk。</p>
<pre><code class="language-shell">wpa_cli -i wlan0 reconfigure
OK
</code></pre>
<p>修改完之后执行该指令，当出现OK的字样说明配置修改完成。ping一下百度看看，ping通了说明WiFi配置完成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树莓派系统配置基础]]></title>
        <id>https://ttlv.github.io/blog/post/shu-mei-pai-xi-tong-pei-zhi-ji-chu/</id>
        <link href="https://ttlv.github.io/blog/post/shu-mei-pai-xi-tong-pei-zhi-ji-chu/">
        </link>
        <updated>2021-01-17T14:40:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-更换国内镜像源">1. 更换国内镜像源</h2>
<p>由于树莓派系统默认的镜像源在国外，所以在国内更新起来会比较慢，好在国内有很多镜像源加速地址，这里我推荐清华的镜像源。</p>
<p>在操作前还请大家先安装vim,自带的nano真的是不好用。</p>
<pre><code class="language-shell">apt install vim
</code></pre>
<p>切换到root权限</p>
<pre><code class="language-shell">sudo su
</code></pre>
<p>编辑文件 <strong>/etc/apt/sources.list</strong></p>
<pre><code class="language-shell">vim /etc/apt/sources.list
</code></pre>
<p>注释掉默认镜像源，换成清华的镜像源</p>
<pre><code class="language-shell">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi
deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi
</code></pre>
<p>编辑 <strong>/etc/apt/sources.list.d/raspi.list</strong>,注释掉默认的内容，添加以下内容</p>
<pre><code class="language-shell">vim /etc/apt/sources.list.d/raspi.list
deb http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui
deb-src http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui
</code></pre>
<p>最后在执行update</p>
<p>在update之前注意下，直接执行apt-get update会把所有本地的包全部升级，甚至包括系统内核，如果一部小学把系统的内核升级了，接下来会遇到一些问题，就是原来可以运行的程序突然就不能运行了，原因就是不兼容更新后的内核版本，所以我们在update之前要阻止更新系统内核</p>
<pre><code class="language-shell">sudo dpkg --get-selections | grep raspberrypi-kernel
raspberrypi-kernel				hold
</code></pre>
<p>因为我已经执行过了锁定操作，所以这里有一个hold的label。默认情况下是没有的。接下来执行锁定操作</p>
<pre><code class="language-shell">sudo apt-mark hold raspberrypi-kernel
</code></pre>
<pre><code class="language-shell">// 最后再自行更新操作
sudo apt update
sudo apt upgrade
</code></pre>
<h2 id="2-打开root角色登录修改root角色密码">2. 打开root角色登录，修改root角色密码</h2>
<p>raspbian默认用户名为pi，密码为raspberry，很多时候操作不是root权限都无法进行，很不方便，所以需要打开root的权限。以后的操作默认用户是已经获取root的权限，即已经执行了sudo su</p>
<pre><code class="language-shell">passwd root // 执行好之后终端会出现下面的输入框，输入密码即可
New password:xxxxxx // 输入密码后会要求再输入一次密码，两次密码需保持一致
Retype new password:xxxxxx
passwd: password updated successfully // 当出现successfully就表示root账户密码修改成功
</code></pre>
<p>启动root账户</p>
<pre><code class="language-shell">passwd --unlock root
passwd: password expiry information changed. // 出现这句话说明已经启动root账户
</code></pre>
<h2 id="3-运行ssh以root角色登录">3. 运行ssh以root角色登录</h2>
<h3 id="1设置ssh允许登录">1.设置ssh允许登录</h3>
<pre><code class="language-shell">sudo sed -i &quot;s/^#PermitRootLogin.*/PermitRootLogin yes/g&quot; /etc/ssh/sshd_config
</code></pre>
<h3 id="2重启ssh服务">2.重启ssh服务</h3>
<pre><code class="language-shell">sudo systemctl restart ssh
</code></pre>
<h3 id="3-生成ssh-key">3. 生成ssh key</h3>
<pre><code class="language-shell">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;
</code></pre>
<h3 id="4-copy你的机器的ssh-key到树莓派中">4. copy你的机器的ssh key到树莓派中</h3>
<pre><code class="language-shell">cd .ssh &amp;&amp; vim authorized_keys
输入你的机器的ssh key即可
:wq保存
</code></pre>
<p>现在你可以直接使用ssh登录了</p>
<pre><code class="language-shell">ssh root@your_raspberry_ip
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树莓派系统烧录]]></title>
        <id>https://ttlv.github.io/blog/post/shu-mei-pai-xi-tong-shao-lu/</id>
        <link href="https://ttlv.github.io/blog/post/shu-mei-pai-xi-tong-shao-lu/">
        </link>
        <updated>2021-01-17T14:23:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="准备工作">准备工作</h1>
<h2 id="1-硬件要求">1 硬件要求</h2>
<h3 id="1-树莓派板子一块">1. 树莓派板子一块</h3>
<p>不管板子是3b,3b+还是4b，什么的，whatever，只要是树莓派的主板就可以了。</p>
<h3 id="2-读卡器">2. 读卡器</h3>
<h3 id="3-sd卡">3. sd卡</h3>
<p>容量不需要太大，16G足以。</p>
<h3 id="4-电源线">4. 电源线</h3>
<p>随便找一个给手机充电的插头就行，然后要一根线，4以下的都是用安卓的口子，4开始就是typeC了。</p>
<h3 id="5-显示器和键盘">5. 显示器和键盘</h3>
<p>当然这两个有最好，没有也没有关系，我们可以通过ssh连入树莓派。</p>
<h2 id="2-软件需求">2. 软件需求</h2>
<h3 id="1-树莓派系统镜像">1.  树莓派系统镜像</h3>
<p>由于树莓派的cpu架构师armfh,所以下的镜像也必须是兼容armfh型号的系统镜像。官方有提供下载镜像地址，这里我贴上链接</p>
<p><a href="https://www.raspberrypi.org/downloads/">树莓派系统下载链接</a></p>
<p>初学者就老老实实的下载Raspberry Pi OS,带不带desktop看自己，如果手上的树莓派板子资源宽裕可以整一个desktop的，不然还是整一个Raspberry Pi OS (32-bit) Lite,我就是整这些花里胡哨的绕了一群回来最后还是装了Raspberry Pi OS (32-bit) Lite,还是这个最好用。</p>
<h3 id="2-内网扫描工具">2.  内网扫描工具</h3>
<p>MACOSX的同学推荐一款免费的内网扫描工具叫LanSacn,直接去App Store就可以下载。</p>
<h3 id="3-烧录程序">3.  烧录程序</h3>
<p>官方有提供烧录系统的软件，在上面那个链接里面就有，不过我不是很喜欢用这个软件。我推荐一下我自己用的。博主是MACOSX的系统，所以这个软件也就针对MACOSX的，软件名字叫balenaEtcher。</p>
<h1 id="准备烧录">准备烧录</h1>
<figure data-type="image" tabindex="1"><img src="https://images-1253546493.cos.ap-shanghai.myqcloud.com/balenaEtcher.jpg" alt="image-20200801071225551" loading="lazy"></figure>
<p>操作很简单就是选择下已经下载好的树莓派系统镜像，然后选择一下要被烧录的sd卡，点击一下flash,等待烧录完成即可。烧录完成之后sd卡不忙着取出来，放两个文件进去。对于没有显示器的同学来说，只有通过ssh的方式连入树莓派，而树莓派默认是关闭ssh的服务的，所以我们现在要唤醒ssh服务，在sd卡中创建一个SSH文件，大小写无所谓，不需要任何内容，一个空文件。要可以使用ssh服务还有一个必须的前提就是让树莓派链上你家的WiFi。让树莓派自动链上WiFi的方法是创建一个文件叫wpa_supplicant.conf</p>
<pre><code class="language-shell">vim wpa_supplicant.conf
# /boot/wpa_supplicant.conf
country=US
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
    ssid=&quot;xxx&quot; // WiFi的名字
    psk=&quot;xxx&quot; // WiFi的密码
    priority=1
}

</code></pre>
<p>把这个文件拖入sd卡中即可。取出sd卡插入树莓派，上电开机。其实这部分内容我在<strong>树莓派网络配置</strong>这一章节也是有提及的，对网络有疑问的同学可以看这里。还有一点是请确保你配置的WiFi是可以接入的，如果树莓派接入不了，ssh是进不去的。</p>
<p>登入树莓派</p>
<p>使用外接显示器的同学在树莓派上电后看到了激动人心的时刻，看到了树莓派的系统界面，最后在登前要求输入用户名和密码。默认的用户名和密码是pi和raspberry。这里是区分大小写的，只能是小写的，要注意下。</p>
<p>没有显示器的同学，如果你用内网扫描工具发现了你的树莓派的ip,那么恭喜你，你可以使用ssh登入树莓派了，登录的步骤是ssh pi@ip,这里的ip就是你用内网扫描工具看到的树莓派的ip,点击enter之后会要求你输入密码，密码就是raspberry，输入密码之后，ok，大功告成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust所有权]]></title>
        <id>https://ttlv.github.io/blog/post/rust-suo-you-quan/</id>
        <link href="https://ttlv.github.io/blog/post/rust-suo-you-quan/">
        </link>
        <updated>2021-01-17T14:14:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-开篇序">1. 开篇序</h2>
<p>所有权可以说是Rust中最为独特的一个功能了。正是所有权概念和相关工具的引入，Rust才能够在没有垃圾回收机制的前提下保障内存安全。因此，正确地理解所有权概念及其在Rust中的实现方式，对于所有Rust开发者来说都是非常重要的。本篇的内容会详细的讨论所有权相关功能:借用，切片以及Rust在内存中布局数据的方式。</p>
<h2 id="2-什么是所有权">2. 什么是所有权</h2>
<p>所有权的概念本身的含义并不复杂，但作为Rust语言的核心功能，它对语言的其他部分产生了十分深远的影响。</p>
<p>一般来讲，所有的程序都需要管理自己在运行时使用的计算机内存空间。某些使用垃圾回收机制的语言会在运行时定期检查并回收那些没有被继续使用的内存:比如golang,java,这些语言都是标准的带有垃圾回收机制的语言，还有一些语言是需要程序员去手动释放内存的，比如C语言，C++。但是Rust确实另辟蹊径，采用了与众不同的第三种方式：它使用包含特定规则的所有权系统来管理内存，这套规则允许编译器在编译过程中执行检查工作，而不产生任何的运行时的开销。</p>
<p>所有权的概念并不是那么的好理解，对于我自己而言本身也是一件非常新鲜的事物。但是已经是做好了心里准备，而且是抱着一定要学会Rust的想法去学习，一定要掌握所有权并且写出高效安全的Rust代码的。</p>
<p>在讲述所有权之前还是要补充一下堆与栈的知识。</p>
<h3 id="21-堆与栈">2.1 堆与栈</h3>
<p>在许多编程语言中，程序员本身就不需要频繁的考虑栈空间和堆空间的区别。但是对于Rust这种系统级的编程语言而言，一个值被存储在堆上还是栈上会极大的影响到语言的行为，进而影响到我们编写代码时的设计选择。</p>
<p>栈和堆都是代码在运行时可以使用的内存空间，不过它们通常以不同的结构组织而成。栈会以我们放入值的顺序来存储它们，并且以相反的顺序将值取出，熟悉数据结构的同学对这些是再熟悉不过了，也就是所谓的&quot;&quot;先进后出&quot;的策略。具象的你可以把栈操作想象成堆放盘子。当你需要放置盘子时，你只能将它们放置在栈的顶部，而你要取出盘子时，正常和安全的操作是从顶部取。从中间和底部去把盘子取出来很不安全，盘子可能会发生意外碎了。用计算机的术语来说就是添加数据这一操作被称为入栈，移除数据则被称为出栈。</p>
<p>所有存储在栈中的数据都必须有一个已知且固定大小的空间。对于那些在编译期无法确定大小的数据，你就只能将它们存储在堆中。堆的空间管理是较为松散的。当你希望将数据放入堆中时，你就可以请求特定大小的空间。操作系统会根据你的请求在堆中找到一块足够大的可用空间。将它们标记为已使用，并把指向这片空间地址的指针返回给我们。这一过程就是所谓的堆分配。它也常常被称为分配。将值压入栈中不叫分配。由于指针的大小是固定的且可以在编译期确定。所以可以将指针存储在栈中。当想要访问指针所指向的具体数据时，可以通过指针指向的地址来访问。</p>
<p>具象化的再举一个例子。我们可以把堆栈的分配的过程想象成是到餐厅聚餐。当你到达餐厅表明自己需要的座位数后，服务员会找到一张足够大的空桌子，并将你们领过去入座。即便这时有小伙伴来迟了，他们也可以通过询问你们就座的位置来找到你们。向栈上推入数据要比我们在堆上进行分配会更有效率些。因为操作系统省去了搜索新数据存储位置的工作；这个位置永远处于栈的顶端。除此之外，操作系统在堆上分配空间时还必须首先找到足够放下对应数据的空间，并进行某些记录工作来协调随后进行的其余分配操作。</p>
<p>由于多了指针跳转的环节，所以访问堆上的数据要慢于访问栈上的数据。一般来说，现代处理器在进行计算的过程中，由于缓存的缘故，指令在内存中跳转的次数越多，性能就越差。继续使用上面的餐厅的例子来做类比。假设现在同时有许多桌的顾客正在等待服务员处理。那么最高效率的处理方式自然是报完一张桌子所有的订单后再接着服务下一张桌子的顾客。而一旦服务员每次在单个桌子前只处理单个订单，那么他就不得不浪费较多的时间往返于不同的桌子之间。由于同样的原因，处理器在操作排布紧密的数据（比如在栈上）时要比操作排布稀疏的数据（比如在堆上）有效率的多。另外，分配命令本身可能也会消耗不少的时钟周期。</p>
<p>许多系统编程语言都需要你记录代码中分配的堆空间。最小化堆上的冗余数据，并及时清理堆上的无用数据以避免消耗空间。而所有权概念则解决了这些问题。一旦熟练的掌握了所有权及其相关工具，就可以将这些问题交给Rust处理，减轻用于思考堆和栈的心智负担。不过，知晓如何使用和管理堆内存可以帮助我们理解所有权存在的意义及其背后的工作原理。</p>
<h3 id="22-所有权规则">2.2 所有权规则</h3>
<p>现在，我们来具体看一下所有权规则。</p>
<ul>
<li>
<p>Rust中每一个值都有一个对应的变量作为它的所有者。</p>
</li>
<li>
<p>在同一时间内，值有且仅有一个所有者。</p>
</li>
<li>
<p>当所有者离开自己的作用域时，它持有的值就会被释放掉。</p>
</li>
</ul>
<h3 id="23-变量作用域">2.3 变量作用域</h3>
<p>第一个示例代码，我们先来了解下变量的作用域。简单来讲作用域是一个对象在程序中有序的范围。假设有这样一个变量</p>
<pre><code class="language-rust">let s = &quot;hello&quot;;
</code></pre>
<p>这里的变量s指向了一个字符串，它的值被硬编码到了当前的程序中。变量从声明的位置开始直到当前作用域结束都是有效的。如</p>
<pre><code class="language-rust">{                            // 由于变量s还未被声明，所有它在这里是不可用的。
		let s = &quot;hello&quot;;         // 从这里开始变量s变得可用。
		xxxxxxxxxx               // 执行与s相关的操作
}                            // 作用域到这里结束，变量s再次不可用
</code></pre>
<p>上面的这段分析有两个重点:</p>
<ul>
<li>s在进入作用域后变得有效。</li>
<li>它会保持自己的有效性直到自己离开作用域为止。</li>
</ul>
<p>到目前为止，Rust语言变量的有效性与作用域之间的关系跟其他编程语言中的类似。现在，让我们继续在作用域的基础上学习String类型。</p>
<h3 id="24-string类型">2.4 String类型</h3>
<p>为了掩饰所有权的相关规则，我们需要一个特别的数据类型，它要比上一章中讲Rust基本数据类型设计的类型更加复杂。之前接触的那些类型会将数据存储在栈上，并在离开自己的作用域时将数据弹出栈空间。我们需要一个存储在堆上的数据类型来研究Rust是如何自动回收这些数据的。</p>
<p>我们将以String类型为例，并将注意力集中到String类型与所有权概念相关的部分。这些部分同样适用于标准库中提供的或者是你自己穿件的其他的复杂的数据类型。之后还是会继续深入的讲解String类型。</p>
<p>上面的代码我们已经知道了什么是字符串变量。他们是那些被硬编码进程序的字符串值。字符串字面量确实是很方便，但它们并不能满足所有需要使用文本的场景。原因之一在于字符串字面量是不可变的。而另一个原因则在于并不是所有字符串的值都能够在编写代码时就确定的，假如我们想要获取用户的输入并保存，应该怎么办呢？为了应对这种情况，Rust提供了第二种字符串类型String。这个类型会在堆上分配到自己需要的存储空间，所以它能够处理在编译时未知大小的文本。你可以调用from函数根据字符串字面量来创建一个String实例：</p>
<pre><code class="language-rust">let s = String::from(&quot;hello&quot;);
</code></pre>
<p>这里的双冒号（::）运算符允许我们调用置于String命名空间下面的特定from函数，而不需要使用类似于String_from这样名字，在后续讲Rust方法的时候会着重讲解这个语法，以及讨论基于模块的命名空间。</p>
<p>上面定义的字符串对象能够被声明为可变的:</p>
<pre><code class="language-rust">let mut s = String::from(&quot;hello&quot;);
s.push_str(&quot;, world&quot;); // push_str()函数向String空间的尾部添加了一段字面量
println(&quot;{}&quot;,s); //这里会输出完整的hello,world!
</code></pre>
<p>或许在此刻你会有一个疑问就是关于为什么String是可变的，而字符串字面量不是？这是因为采用了不同的内存处理方式。</p>
<h3 id="25-内存与分配">2.5 内存与分配</h3>
<p>对于字符串字面量而言，由于我们在编译时就知道其内容，所以这部分硬编码的文本被直接嵌入到了最终的可执行文件中。这就是访问字符串字面量异常高效的原因，而这些性质完全得益于字符串字面量的不可变性。不幸的是，我们没有办法将那些未知大小的文本在编译期统统放入二进制文件中，更何况这些文本的大小还可能随着程序的运行而发生改变。</p>
<p>对于String类型而言，为了支持一个可变的，可增长的文本类型，我们需要在堆上分配一块在编译时未知大小的内存来存放数据。这同时也是意味着:</p>
<ul>
<li>我们使用的内存是由操作系统在运行时动态分配出来的。</li>
<li>当使用完String时，我们需要通过某种方式来将这些内存归还给操作系统。</li>
</ul>
<p>这里的第一步由我们，也就是程序的编写者，在调用String::from时完成，这个函数会请求自己需要的内存空间。在大部分编程语言中都有类似的设计：由程序员来发起堆内存的分配请求。</p>
<p>然而，对于不同的编程语言来说，第二步实现起来就各有区别了。在某些拥有垃圾回收（Garbage Collector ,GC）机制的语言中，GC会代替程序员来负责记录并清除那些不再使用的内存。而对于那些没有GC的语言来说，识别不在使用的内存并调用代码显示释放的工作就依然需要由程序员去完成，正如我们请求分配时一样。按照以往的经验来看，正确地完成这些任务往往是十分困难的。假如我们忘记释放内存，那么就会造成内存泄漏：假如我们过早的释放内存，那么就会产生一个非法变量；假如我们重复释放同一块内存，那么就会产生无法预知的后果。为了程序的稳定运行，我们必须严格地将分配和释放操作一一对应起来。</p>
<p>与这些语言不同，Rust提供了另外一套解决方案：内存会自动地在拥有它的变量离开作用域后进行释放。下面的代码类似于示例中的代码，不过我们将字符串字面量换成了String类型：</p>
<pre><code class="language-rust">{
		let s = String::from(&quot;hello&quot;); // 从这里开始，变量s变得有效
		xxxxxxxxxxxxxxxx // 执行与s相关的操作
		// 作用域到这里结束，变量s失效
}
</code></pre>
<p>审视上面的代码，有一个很适合用来回收内存给操作系统的地方：变量s离开作用域的地方。Rust在变量离开作用域时，会调用一个叫drop的特殊函数。String类型的作者可以在这个函数中编写释放内存的代码。记住，Rust会在作用域结束的地方（即}处）自动调用drop函数。</p>
<p><strong>注意:</strong></p>
<p>在C++中，这种在对象生命周期结束时释放资源的模式有时也被称作资源获取即初始化（Resource Acquisition Is Initialization,RAII）。假如你使用过类似的模式，那么你应该对Rust中的特殊函数drop并不陌生。</p>
<p>这种模式极大地影响了Rust中的许多设计模块，并最终决定了我们现在编写Rust代码的方式。在上面的例子中，这套释放机制看起来也许还算简单，然而一旦把它放在默写更加复杂的环境中，代码呈现出来的行为往往会出乎你的意料，特别是当我们拥有多个指向同一处堆内存的变量时。让我们接着来看一看其中一些可能使用的场景。</p>
<h4 id="251-变量和数据交互的方式移动">2.5.1 变量和数据交互的方式:移动</h4>
<p>Rust中的多个变量可以采用一种独特的方式与同一数据进行交互。接下来我们来看一段代码，使用了一个整型作为数据：</p>
<pre><code class="language-rust">let x = 5;
let y = x;
</code></pre>
<p>示例中的代码将变量X绑定的整数值重新绑定到变量y上，你也许能够猜到这段代码的执行效果：将整数值5绑定到变量x上：然后创建一个x值的拷贝，并将它绑定到y上。结果我们有了两个变量x和y，它们的值都是5。这正是实际发生的情形，因为整数是已知固定大小的简单值，两个值5会同时被推入当前栈中。</p>
<p>现在让我们下上述代码的String版本：</p>
<pre><code class="language-rust">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
</code></pre>
<p>以上这两段代码非常相似，你也许会假设他们的运行能力也是一致的。也就是说，第二行代码可能会生成一个s1值的拷贝，并将它绑定到s2上。不过实际上并非如此。</p>
<p>String的示例代码展示了String的内存布局，它实际上由3部分组成，如下图左侧所示：一个指向存放字符串内容的指针（ptr），一个长度（len）及一个容量（capacity），这部分的数据存放在了栈中。图片右侧显示了字符串存储在堆上的文本内容</p>
<figure data-type="image" tabindex="1"><img src="https://images-1253546493.cos.ap-shanghai.myqcloud.com/mem_layout.jpg" alt="image-20200815023430437" loading="lazy"></figure>
<p>​                                                                                    <strong>绑定到变量s1上，拥有值&quot;hello&quot;的String的内存布局</strong></p>
<p>长度字段被用来记录当前String的文本使用了多少字节的内存。而容量字段则被用来记录String向操作系统总共获取到的内存字节数量。长度和容量之间的区别十分重要，但我们先不去讨论这个问题，简单地忽略内容字段即可。</p>
<p>当我们将s1赋值给s2时，便复制了一次String的数据，这意味着我们复制了它存储在栈上的指针，长度以及容量字段。但需要注意的是，我们没有复制指针指向的堆数据。换句话说，此时的内存布局应该是类似于下图</p>
<figure data-type="image" tabindex="2"><img src="https://images-1253546493.cos.ap-shanghai.myqcloud.com/mem_layout_1.jpg" alt="image-20200815023430437" loading="lazy"></figure>
<p>​                                                                                    <strong>变量s2在复制了s1的指针，长度及容量后的内存布局</strong></p>
<p>由于Rust不会在复制时深度地复制堆上的数据，所以这里的布局不会像下图所以的那样。</p>
<figure data-type="image" tabindex="3"><img src="https://images-1253546493.cos.ap-shanghai.myqcloud.com/mem_layout_2.jpg" alt="image-20200815023430437" loading="lazy"></figure>
<p>​                                                                    <strong>当Rust也复制了堆上的数据时，执行完s2=s1语句后可能产生的布局内存</strong></p>
<p>假如Rust依旧这样的模式去执行赋值，那么当堆上的数据足够大时，类似于s2=s1这样的指令就会造成相当可观的运行时的性能消耗。</p>
<p>前面我们提到过，当一个变量离开当前的作用域时，当Rust会自动调节它的drop函数，并将变量使用的堆内存释放回收。不过，第二张图展示的内存布局里有两个指针指向了同一个地址，这就导致了一个问题：当s2和s1离开自己作用域时，它们会尝试去重复释放相同的内存。这也就是我们之前提到过的内存的错误之一，臭名昭著的二次释放。重复释放内存可能会导致某些正在使用的数据发生损坏，进而产生潜在的安全隐患。</p>
<p>为了确保内存安全，同时避免了复制分配的内存，Rust在这种场景下会简单的将s1废弃，不再视其为一个有效的变量。因此，Rust也不需要在s1离开作用域后清理任何东西。试图在s2创建完毕后使用s1，如下所示会导致编译错误。</p>
<pre><code class="language-rust">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
println(&quot;{},world!&quot;,s1)
</code></pre>
<p>为了阻止你使用的无效的引用，Rust会产生类似于下面的错误提示</p>
<pre><code class="language-shell">error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:4:26
  |
2 |     let s1 = String::from(&quot;hello&quot;);
  |         -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |     println!(&quot;{},world!&quot;,s1);
  |                          ^^ value borrowed here after move

error: aborting due to previous error; 1 warning emitted
</code></pre>
<p>假如你在其他语言中接触过浅度拷贝（shallow copy）和深度拷贝（deep copy）这两个术语，那么你也许会将这里复制指针，长度以及容量字段行为视作浅度拷贝。但由于Rust同时使第一个变量无效了，所以我们使用了新的术语移动（move）来描述这一行为，而不再使用浅度拷贝。在上面的示例中我们可以说s1被移动到了s2中。在这个过程中所发生的的操作如下图所示。</p>
<p>https://images-1253546493.cos.ap-shanghai.myqcloud.com/mem_layout_move.jpg</p>
<figure data-type="image" tabindex="4"><img src="https://images-1253546493.cos.ap-shanghai.myqcloud.com/mem_layout_move.jpg" alt="image-20200815054204580" loading="lazy"></figure>
<p>​                                                                                                         <strong>s1变为无效之后的内存布局</strong></p>
<p>这一语义完美的解决了我们的问题！既然只有s2有效，那么也就只有它会在离开自己的作用域时释放空间，所以再也没有二次释放的可能性了。另外，这里还隐含了另外一个设计原则：Rust永远不会自动地创建数据的深度拷贝。因此在Rust中，任何自动的赋值操作都可以被视为高效的。</p>
<h4 id="252-变量和数据交互的方式-克隆">2.5.2 变量和数据交互的方式： 克隆</h4>
<p>都拿你确实系要去深度拷贝String堆上的数据，而不仅仅是栈数据时，就可以使用一个名为clone的方法。后面的篇章中会详细讨论类型方法的语法，但你应该在其他语言中见过类似的东西。</p>
<p>下面是一个实际使用clone方法的例子：</p>
<pre><code class="language-rust">lets s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();
println!(&quot;s1 = {},s2 = {}&quot;,s1,s2)
</code></pre>
<p>这段代码在Rust中完全合法，它显示的生成了第三张图的行为：赋值了堆上的数据。当你看到某处调用了clone时，你就应该知道某些特定的代码将会被执行，而且这些代码可能会相当的消耗资源。你可以很容易的在代码中觉察到一些不同寻常的事情正在发生。</p>
<h4 id="253-栈上数据的复制">2.5.3 栈上数据的复制</h4>
<p>上面的讨论中遗留了一个没有提及的知识点。我们在示例中曾经使用整型编写了如下的合法代码</p>
<pre><code class="language-rust">let x = 5;
let y = x;
println!(&quot;x = {},y = {}&quot;,x,y);
</code></pre>
<p>这与我们刚刚在上面说到的内容有些矛盾，即便代码没有调用clone，x在被赋值给y后也依然有效，且没有发生移动现象。</p>
<p>这是因为类似于整型的类型可以在编译时确定自己的大小，并且能够将自己的数据完整地存储在栈中，对于这些值的复制操作永远都是非常快速的。这也同样意味着，在创建变量y之后，我们没有任何理由去阻止变量x继续保持有效。换句话说，对于这些类型而言，深度拷贝与浅度拷贝没有任何区别，调用clone并不会与直接的浅度拷贝有任何行为上的区别。因此，我们完全不惜要在类似的场景中考虑上面的问题。</p>
<p>Rust提供了一个名为Copy的trait，它可以用于整数这类完全存储在栈上的数据类型，啥是trait在后续会有详细的说明。一旦某种类型拥有了Copy这种trait，那么它的变量就可以在赋值给其他变量之后保存可用性。如果一种类型本身或这种类型的任意成员实现了实现了Drop这种trait，那么Rust就不允许其实现Copy这种trait。尝试给某个需要在离开作用域时执行特殊指令的类型实现Copy这种trait会导致编译时错误。</p>
<p>那么究竟哪些类型是Copy的，可以去查一下文档来确定，不过一般来说，任何简单标量的组合类型都可以是Copy的，任何需要分配内存或某种资源的类型都不会是Copy的。下面是一些拥有Copy这种trait的类型：</p>
<ul>
<li>所有的整数类型，诸如u32</li>
<li>仅拥有两种值(true 和 false)的布尔类型：bool</li>
<li>字符类型：char</li>
<li>所有的浮点类型，诸如f64</li>
<li>如果元组包含的所有字段的类型都是Copy的，那么这个元组也是Copy的。诸如（i32,i32）是Copy的，但是（i32,String）则不是。</li>
</ul>
<h3 id="26-所有权与函数">2.6 所有权与函数</h3>
<p>将值传递给函数在语义上类似于对变量进行赋值。将变量传递给函数将会触发移动或复制，就像是赋值语句一样。</p>
<pre><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;); // 变量s进入作用域

    takes_ownership(s); // s的值被移动进了函数，所以它从这里开始不再有效

    let x = 5; // 变量x进入作用域

    make_copy(x) //变量x同样被传递进了函数，但由于i32是Copy的，所以我们依然可以在这之后使用x
} // x首先离开作用域,随后是s。

// 但是由于s的值已经发生了移动，所有没有什么特别的事情会发生。

fn takes_ownership(some_string: String){ // some_string进入作用域
println!(&quot;{}&quot;,some_string);
} // some_string在这里离开作用域，drop函数被自动调用，some_string所占用的内存也就随之被释放了

fn make_copy(some_integer: i32){ // some_integer 进入作用域
    println!(&quot;{}&quot;,some_integer);
} // some_integer在这里离开作用域，没有发生什么特别的事情

</code></pre>
<p>尝试在调用takes_ownership后使用变量s会导致编译时错误。这类静态检查可以使我们免于犯错。你可以尝试在main函数中使用s和x变量，来看一下所有权规则的约束下能够在哪些地方合法的使用他们。</p>
<h3 id="27-返回值与作用域">2.7 返回值与作用域</h3>
<p>函数在返回值的过程中也会发生所有权的转移。</p>
<pre><code class="language-rust">fn main() {
    let s1 = gives_ownership(); // gives_ownership将它的返回值移动至s1中


    let s2 = String::from(&quot;hello&quot;); // s2进入作用域


    let s3 = take_and_gives_back(s2); // s2被移动进函数

    // take_and_gives_back中，而这个函数的返回值又被移动到了变量s3上
} // s3在这里离开作用域并被销毁，由于s2已经移动了，所以它不会在离开作用域时发生任何事情。s1最后离开作用域并被销毁。

fn gives_ownership() -&gt; String{ // gives_ownership会将它的返回值移动至调用它的函数内
    let some_string = String::from(&quot;hello&quot;); // some_string进入作用域
    some_string // some_string作为返回值移动至调用函数
}

// take_and_gives_back将取得一个String的所有权并将它作为结果返回
fn take_and_gives_back(a_String: String) -&gt; String {
    // a_String进入作用域
    a_String // a_String作为返回值移动至调用函数
}
</code></pre>
<p>​                                                                                            <strong>函数在返回值时所有权的转移过程</strong></p>
<p>变量所有权的转移总是遵循相同的模式：将一个值赋值给另一个变量时就会转移所有权。当一个持有堆数据的变量离开作用域时，它的数据就会被drop清理回收，除非这些数据的所有权移动到了另一个变量上。</p>
<p>在所有的函数中都要获取所有权并返回所有权显得有些繁琐。假如你希望在调用函数时保留参数的所有权，那么就不得不将传入的值作为结果返回。除了这些需要保留所有权的值，函数还可能会返回它们本身的结果。</p>
<p>当然你也可以利用元组来同时返回多个值。</p>
<pre><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2,len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;,s2,len);

}

fn calculate_length(s: String) -&gt; (String,usize){
    let length = s.len(); // len()会返回当前字符串的长度

    (s,length)
}
</code></pre>
<p>​                                                                                                       <strong>返回参数的所有权</strong></p>
<p>但这种写法未免太过笨拙了，类似的概念在编程工作中相当常见。幸运的是，Rust针对这类场景提供了一个名为引用的功能。</p>
<h3 id="28-引用与借用">2.8 引用与借用</h3>
<p>在 <strong>返回参数的所有权</strong>的示例代码中，由于调用了calculate_length会导致String移动到函数体内部，而我们又希望在调用完毕之后继续使用该String，所以我们不得不使用元组将String作为元素再次返回。</p>
<p>下面的示例重新定义了一个新的calculate_length函数。与之前不同的是，新的函数签名使用了String的引用作为参数而没有直接转移值的所有权。</p>
<pre><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;,s1,len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre>
<p>首先需要注意的是，变量声明及函数返回值中的那些元组代码都消失了。我们调用calculate_length函数使用了&amp;s1作为参数，且在该函数的定义中，我们使用&amp;String替代了String。</p>
<p>这些&amp;代表的就是引用语义，它们允许你在不获取所有权的前提下使用值，如下图的图解</p>
<figure data-type="image" tabindex="5"><img src="https://images-1253546493.cos.ap-shanghai.myqcloud.com/%26String%20s-%3EString%20s1.jpg" alt="image-20200816060738083" loading="lazy"></figure>
<p>​                                                                                                      <strong>&amp;String s 指向String s1的图解</strong></p>
<p>注意：</p>
<p>与使用&amp;进行引用相反的操作被称为解引用（dereferencing），它使用*作为运算符。解应用的使用场景会在后续的章节补上。</p>
<p>现在，让我们观察下这个函数的调用过程</p>
<pre><code class="language-rust">let s1 = String::from(&quot;hello&quot;);

let len = calculate_length(&amp;s1);
</code></pre>
<p>这里的&amp;s1语法允许我们在不转移所有权的前提下，创建一个指向s1值的引用。由于引用不持有值的所有权，所以当引用离开当前的作用域时，它指向的值也不会被丢弃。</p>
<p>同理，函数签名中的&amp;用来表明参数s的类型是一个引用。下面的注释给出了更详细的解释：</p>
<pre><code class="language-rust">fn calculate_length(s: &amp;String) -&gt; usize{ // s是一个指向String的引用
s.len()
} // 到这里，s离开作用域。但是由于它并不持有自己所指向值的所有权，所以没有用什么特殊的事情会发生
</code></pre>
<p>此处，变量s的有效作用域与其他任何参数一样，唯一不同的是，它不会在离开自己的作用域时销毁其指向的数据，因为它并不拥有该数据的所有权。当一个函数使用引用而不是值本身作为参数时，我们便不需要为了归还所有权而特意去返回值，毕竟在这种情况下，我们根本没有获得所有权。</p>
<p>这种通过引用传递参数给函数的方法也被称为借用（borrowing）。但在现实生活中，假如一个人拥有某种东西，你可以从他那里把东西借过来，但是当你使用完毕时，就必须将东西还回去。</p>
<p>如果我们尝试着修改借用的值又会发生什么？尝试下修改一下代码，这里我先给出结果：无法通过编译</p>
<pre><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);
    change(&amp;s);
}

fn change(some_string: &amp;String){
    some_string.push_str(&quot;world&quot;);
}
</code></pre>
<p>​                                                                                                            <strong>尝试修改借用的值</strong></p>
<p>编译的结果:</p>
<pre><code class="language-shell">error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:7:5
  |
6 | fn change(some_string: &amp;String){
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut std::string::String`
7 |     some_string.push_str(&quot;world&quot;);
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
</code></pre>
<p>与变量类似，应用默认也是不可变的。Rust不允许我们去修改引用指向的值。</p>
<h3 id="29-可变引用">2.9 可变引用</h3>
<p>我们可以通过进行一个小小的调整来修复2.8中的代码示例</p>
<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);
    change(&amp;mut s);
}

fn change(some_string: &amp;mut String){
    some_string.push_str(&quot;world&quot;);
}
</code></pre>
<p>首先，我们需要将变量s声明为mut，即可变的。其实，我们使用&amp;mut来给函数传入一个可变引用，并将函数签名修改为some_string: &amp;mut String来使其可以接受一个可变引用作为参数。</p>
<p>单可变引用在使用上有一个很大的限制：对于特定作用域中的特定数据来说，一次只能声明一个可变引用。以下代码尝试违背这一限制，则会导致编译错误：</p>
<pre><code class="language-rust">    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;
    println!(&quot;{},{},{}&quot;,s,r1,r2);
</code></pre>
<p>出现的错误如下所示：</p>
<pre><code class="language-shell">error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:4:14
  |
3 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
4 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
5 |     println!(&quot;{},{},{}&quot;,s,r1,r2);
  |                           -- first borrow later used here
</code></pre>
<p>这个规则使得引用的可变性只能以一种受到严格限制的方式来使用。刚刚接触Rust的开发者会反复的与他们进行斗争，因为大部分的语言都允许你随意修改变量。</p>
<p>但在另外一方面，在Rust中遵循这条限制性规则则可以帮助我们在编译中避免数据竞争。数据竞争（data race）与竞态条件十分类似，它会在指令满足以下3种情形下发生：</p>
<ul>
<li>两个或两个以上的指针同事访问同一空间</li>
<li>其中至少有一个指针会向空间中写入数据</li>
<li>没有同步数据访问的机制</li>
</ul>
<p>数据竞争会导致未定义的行为，由于这些未定义的行为往往难以在运行时跟踪，也就使得出现的bug更加难以被诊断和修复。Rust则完全避免了这种情形，因为存在数据竞争的代码连编译检查都无法通过！</p>
<p>与大部分语言类似，我们可以通过或括号来创建一个新的作用域范围，这就使我们可以创建多个可变引用，当然，这些可变引用不会同时存在：</p>
<pre><code class="language-rust">let mut s = String::from(&quot;hello&quot;);

{
  let r1 = &amp;mut s;
} // 由于r1在这里离开了作用域，所以我们可以合法地再创建一个可变引用。

  let r2 = &amp;mut s; 
</code></pre>
<p>在结合使用可变引用于不可变引用时，还有另外一条类似的限制规则，它会导致下面的代码编译失败：</p>
<pre><code class="language-shell">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:5:14
  |
3 |     let r1 = &amp;s; // 没问题
  |              -- immutable borrow occurs here
4 |     let r2 = &amp;s; // 没问题
5 |     let r3 = &amp;mut s; // 错误
  |              ^^^^^^ mutable borrow occurs here
6 |     println!(&quot;{},{},{}&quot;,r1,r2,r3);
  |                         -- immutable borrow later used here
</code></pre>
<p>不知道大家有没有发现，我们不能在拥有不可变引用的同时创建可变引用。听上去有点拗口，像是一句绕口令。不可变引用的用户可不会希望他们眼皮底下的值突然发生变化！不过，同时存在多个不可变引用是合理合法的，对数据的只读操作不会影响到其他读取数据的用户。</p>
<p>尽管这些编译错误会让人感到沮丧，但是要牢记一点：Rust编译器可以为我们提早（在编译时而不是在运行时）暴露那些潜在的bug，并且明确指出出现问题的地方。你不再需要去追踪调试为何数据会在运行时发生了非预期的变化。</p>
<h3 id="210-悬垂引用">2.10 悬垂引用</h3>
<p>是用拥有多指针概念的语言会非常容易错误地创建悬垂指针。这类指针指向曾经存在的某处内存地址，但该内存已经被释放掉甚至是被重新分配另作他用了。而在Rust语言中，编译器会确保引用永远不会进入这种悬垂状态。假如我们当前持有某一个数据的引用，那么编译器可以保证这个数据不会在引被销毁前离开自己的作用域。</p>
<p>我们来创建一个悬垂引用，看看Rust是如何在编译期发现这个错误的：</p>
<pre><code class="language-rust">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);
    &amp;s
}
</code></pre>
<pre><code class="language-shell">rror[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                ^^^^^^^^
</code></pre>
<p>这段错误提示信息包含了一个目前还未讲解过的新概念：生命周期。后续会出章节详细讨论。不过即使我们先将生命周期放置不管，这条错误提示信息也准确的指出了代码中的问题：</p>
<pre><code class="language-shell"> this function's return type contains a borrowed value, but there is no value for it to be borrowed from
</code></pre>
<p>仔细的看下dangle函数中发生了什么</p>
<pre><code class="language-rust">fn dangle() -&gt; &amp;String { // 返回一个指向String的引用
    let s = String::from(&quot;hello&quot;); // s被绑定到新的String上
    &amp;s // 我们将指向s的引用返回给调用者，变量s在这里离开作用域并随之被销毁，它指向的内存自然也不会再有效。一个危险的操作
}
</code></pre>
<p>由于变量s创建在函数dangle内，所以它会在dangle执行完毕随之释放。但是，我们的代码依旧尝试返回一个指向s的引用，这个引用指向的是一个无效的String，这可不对！Rust成功地拦截了我们的危险代码。</p>
<p>解决这个问题的方法也很简单，直接返回String就好：</p>
<pre><code class="language-rust">fn no_dangle() -&gt; String {
  let s = String::from(&quot;hello&quot;);
  
  s
}
</code></pre>
<p>这种写法没有任何问题，所有权被转移出函数，自然也就不会涉及释放操作了。</p>
<h3 id="211-引用的规则">2.11 引用的规则</h3>
<p>让我们简要的概括下对引用的讨论：</p>
<ul>
<li>在任何一段给定的时间里，你要么只能拥有一个可变的引用，要么只能拥有任意数量的不可变引用。</li>
<li>引用总是有效的</li>
</ul>
<p>接下来着重研究一下引用的另外一种形式：切片</p>
<h3 id="212-切片">2.12 切片</h3>
<p>除了引用，Rust还有另外一种不持有所有权的数据类型：切片(slice)。</p>
<p>切片允许我们引用集合中某一段连续的元素序列，而不是整个集合。</p>
<p>考虑到这样一个小问题；编写一个搜索函数，它接收字符串作为参数，并将字符串中的首个单词作为结果返回。如果字符串中不存在空格，那么就意味着整个字符串是一个单词，直接返回整个字符串作为结果即可。</p>
<p>让我们来看下这个函数的签名该如何设计：</p>
<pre><code class="language-rust">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<p>由于我们不需要获得传入的所有权，所以这个函数first_word采用了&amp;String作为参数。但它应该返回什么？我们还没有一个获取部分字符串的方法。当然，你可以将首个单词结尾处的索引返回给调用者，如示:</p>
<pre><code class="language-rust">fn first_word(s:&amp;String) -&gt; usize{
    ① let bytes = s.as_bytes(); 

    for(i,&amp;item)② in bytes.iter()③.enumerate(){
        ④ if item == b' ' {
            return i;
        }
    }
  ⑤ s.len()
}
</code></pre>
<p>​                                                                    <strong>first_word函数会返回String参数中首个单词结尾处的索引作为结果</strong></p>
<p>这段代码首先使用as_byte①将String转换为字节数组，因为我们的算法需要依次检查String中的字节是否为空格。接着，我们通过iter③方法创建了一个可以遍历字节数组的迭代器。</p>
<p>迭代器后续再详细讨论。目前，我们只需知道iter方法会依次返回集合中的每一个元素即可。随后的enumerate则将iter的每个输出作为元素逐一封装在对应的元组中返回。元组的第一个元素是索引，第二个元素是指向集合中字节的引用。使用enumerate可以较为方便地获得迭代索引。</p>
<p>既然enumerate方法返回的是一个元组，那么我们就可以使用模式匹配来结构他它，就像是Rust中其他使用元组的地方一样。在for循环的遍历语句中，我们指定了一个解构模式，其中i是元组中的索引部分，而&amp;item②则是元组中指向集合元素的引用。由于我们从.iter().enumerate()中获取的是产生引用元素的迭代器，所以我们在模式中使用了&amp;。</p>
<p>在for循环的代码块中，我们使用了字节字面量语法来搜索数组中代表这空格的字节④。这段代码会在搜索到空格时返回当前的位置索引，并在搜索失败时返回传入字符串的长度s.len()。⑤</p>
<p>现在，我们初步实现了期望的功能，它能够成功地搜索并返回字符串中第一个单词结尾处的位置索引。但这里依然存在一个设计上的缺陷。我们将一个usize值作为索引独立地返回给调用者，但这个值脱离了传入的&amp;String的上下文之后便毫无意义。换句话说，由于这个值独立于String而存在，所以在函数返回后，我们就再也无法保证它的有效性了。下面的示例中使用first_word函数演示了这种返回值失效的情形。</p>
<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello world&quot;);
    let _word = first_word(&amp;s); // 索引5会被绑定到变量word上
    s.clear(); // 这里的clear方法会清空当前字符串，使之变为&quot;&quot;
    // 虽然word依然拥有这5个值，但因为我们用于搜索的字符串发生了改变
    // 所以这个索引也就没有任何意义了，word到这里变失去了有效性。
}

fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();
    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }
    s.len()
}
</code></pre>
<p>​                                                                                    <strong>保存first_word产生的返回值并改变其中String的内容</strong></p>
<p>上面的程序编译没有任何问题，即便我们在调用s.clear()之后使用_word变量也是没有问题的。同事由于_word变量本身与s没有任何关联，所以_word的值始终是5。但当我们再次使用5去从变量s中提取单词时，一个bug就出现了：此时s中的内容早已在我们将5存入_word后发生了改变。</p>
<p>这种API的设计方式使我们需要随时关注_word的有效性，确保它与s中的数据是一致的，类似的工作往往相当烦琐且易于出错。这种情况对于另一个函数second_word而言更加明显。这个函数被设计来搜索字符串中的第二个单词，它的签名也许被设计为下面这样：</p>
<pre><code class="language-rust">fn second_word(s:&amp;String) -&gt; (usize,usize){}
</code></pre>
<p>现在，我们需要同时维护起始和结束两个位置的索引，这两个值基于数据的某个特定状态计算而来，却没有跟数据产生任何程度上的联系。于是我们有了3个彼此不相关的变量需要被同步，这可不妙。</p>
<p>幸运的是，Rust为这个问题提供了解决方案：字符串切片。</p>
<h3 id="213-字符串切片">2.13 字符串切片</h3>
<p>字符串切片是指向String对象中某个连续部分的引用，它的使用方法如下所示</p>
<pre><code class="language-rust">let s = String::from(&quot;hello world&quot;);

let hello = &amp;s[0..5];
①let world = &amp;s[6..11];
</code></pre>
<p>这里的语法与创建指向整个String对象的引用有些类似，但不同的是新的语法在结尾的地方多出了一段[0..5]。这段额外的声明告诉编译器我们正在创建一个String的切片引用，而不是对整个字符串本身的引用。</p>
<p>我们可以在一对方括号中指定切片的范围区间[starting_index,ending_index]，其中starting_index是切片起始位置的索引值，ending_index是切片终止位置的下一个索引值。切片数据结构在内部存储了指向起始位置的引用和一个描述切片长度的字段，这个描述切片长度的字段等价于ending_index减去starting_index。所以在上面实例的①中，world是一个指向变量s第七个字节并且长度为5的切片。</p>
<figure data-type="image" tabindex="6"><img src="https://images-1253546493.cos.ap-shanghai.myqcloud.com/string_slice.jpg" alt="image-20200822101453486" loading="lazy"></figure>
<p>​                                                                                    <strong>指向String对象中某个连续部分的字符串切片</strong></p>
<p>Rust的范围语法..有一个小小的语法糖：当你希望范围从第一个元素(也就是索引值为0的元素)开始时，则可以省略两个点号之前的值。换句话说，下面两个创建切片的表达式是等价的：</p>
<pre><code class="language-rust">let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
</code></pre>
<p>同样地，假如你的切片想要包含String中的最后一个字节，你也可以省略双点号之后的值。下面的切片表达式依然是等价的：</p>
<pre><code class="language-rust">let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[3..len];

let slice = &amp;s[3..];
</code></pre>
<p>你甚至可以同时省略首位的两个值，来创建一个指向整个字符串所有字节的切片:</p>
<pre><code class="language-rust">let s = String::from(&quot;hello&quot;);
let len = s.len();
let slice = &amp;s[0..len];
let slice = &amp;s[..];
</code></pre>
<p>字符串切片的边界必须位于有效的UTF-8字符边界内。尝试从一个多字节字符的中间位置创建字符串切片会导致运行时错误。为了将问题简化，现在使用ASCII字符集，至于UTF-8后续再做讨论。</p>
<p>基于上述的知识，让我们开始重构first_word函数。该函数可以返回一个切片作为结果。字符串切片的类型写作&amp;str：</p>
<pre><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();
    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }
    &amp;s[..]
}
</code></pre>
<p>这个新函数中搜索首个单词索引的方式类似于示例  <strong>first_word函数会返回String参数中首个单词结尾处的索引作为结果</strong>中的代码。一旦搜索成功，就返回一个从首字符开始带这个索引位置结束的字符串切片。</p>
<p>调用新的first_word函数会返回一个与底层数据紧密联系的切片作为结果，它由指向起始位置的引用和描述元素长度的字段组成。</p>
<p>当然我们也可以以同样的方式重构second_word函数</p>
<pre><code class="language-rust">fn second_word(s: &amp;String) -&gt; &amp;str{}
</code></pre>
<p>由于编译器会确保指向String的引用持续有效，所以我们新设计的接口变得更加健壮直观了。还记得在示例  <strong>保存first_word产生的返回值并改变其中String的内容</strong>中故意构造出的错误嘛？这段代码在搜索完成并保存索引后清空了字符串的内容，这使得我们存储的索引不再有效。它在逻辑上明显是有问题的，却不会触发任何编译错误，这个问题只会在我们使用第一个单词的索引去读取空字符串暴露出来。切片的引入使我们可以在开发早期快速地发现此类错误。示例<strong>保存first_word产生的返回值并改变其中String的内容</strong>中，新的first_word函数在编译时会抛出一个错误，尝试运行以下代码：</p>
<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello world&quot;);
    let _word = first_word(&amp;s);
    s.clear();  //错误
    println!(&quot;the first word is: {}&quot;,_word);
}

fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();
    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }
    &amp;s[..]
}
</code></pre>
<p>编译结果</p>
<pre><code class="language-rust">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:4:5
  |
3 |     let _word = first_word(&amp;s);
  |                            -- immutable borrow occurs here
4 |     s.clear(); 
  |     ^^^^^^^^^ mutable borrow occurs here
5 |     println!(&quot;the first word is: {}&quot;,_word);
  |                                      ----- immutable borrow later used here
</code></pre>
<p>回忆一下借用的规则，当我们拥有了某个变量的不可变引用时，我们就无法同时取得该变量的可变引用。由于clear需要截断当前的String实例，所以调用clear需要传入一个可变引用。这就是编译失败的原因。Rust不仅使我们的API更加易用，它还在编译过程中帮助我们避免了此类错误。</p>
<h4 id="2131-字符串字面量就是切片">2.13.1 字符串字面量就是切片</h4>
<p>还记得Rust字符串字面量被直接存储在了二进制程序中吗？在学习了切片之后，我们现在可以更恰当地理解字符串字面量了：</p>
<pre><code class="language-rust">let s = &quot;Hello,World!&quot;;
</code></pre>
<p>在这里，变量s的类型其实就是&amp;str，它是一个指向二进制程序特定位置的切片。正是由于&amp;str是一个不可变的引用，所以字符串字面量自然才是不可变的。</p>
<h4 id="2132-将字符串切片作为参数">2.13.2 将字符串切片作为参数</h4>
<p>既然我们可以分别创建字符串字面量和String的切片，那么就能够进一步优化first_word函数的接口，下面就是它目前的签名：</p>
<pre><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str{}
</code></pre>
<p>比较有经验的Rust开发者往往会采用下面的写法，这种改进后的签名使函数可以同时处理String与&amp;str;</p>
<pre><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str{}
</code></pre>
<p>​                                                                  <strong>使用字符串切片作为参数s的类型来改进first_word函数</strong></p>
<p>当你持有字符串切片时，你可以直接调用这个函数。而当你持有String时，你可以创建一个完整String的切片来作为参数。在定义函数时使用字符串切片来代替字符串引用会使我们的API更加通用，且不会损失任何功能，尝试运行以下代码：</p>
<pre><code class="language-rust">fn main() {
let my_string = String::from(&quot;hello world&quot;);
// first_word可以接收String对象的切片作为参数
let word = first_word(&amp;my_string[..]);

let my_string_literal = &quot;hello world&quot;;

// first_word可以接收字符串字面量的切片作为参数

let word = first_word(&amp;my_string_literal[..]);

//由于字符串字面量本身就是切片，所以我们可以在这里直接将它传入函数
// 而不需要使用额外的切片语法
let word = first_word(my_string_literal);
}

fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();
    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }
    &amp;s[..]
}
</code></pre>
<h3 id="214-其他类型切片">2.14 其他类型切片</h3>
<p>从名字上可以看出来，字符串切片是专门用于字符串的。但实际上，Rust还有其他更加通用的切片类型，以下面数组为例：</p>
<pre><code class="language-rust">let a = [1,2,3,4,5];
</code></pre>
<p>就像我们想要引用字符串的某个部分一样，你也可能希望引用数组的某个部分。这是，我们可以这样做</p>
<pre><code>let a = [1,2,3,4,5];

let slice = &amp;a[1..3];
</code></pre>
<p>这里的切片类型是&amp;[i32]，它在内部存储了一个指向起始元素的引用及长度，这与字符串切片的工作机制完全一样。你将在各种各样的集合中接触到此类切片，而我们会在后续的学习中再来介绍哪些常用的集合。</p>
<h2 id="3-总结">3. 总结</h2>
<p>所有权，借用和切片的概念是Rust可以在编译时保证内存安全的关键所在。像其他系统语言一样，Rust语言给与了程序员完善的内存使用控制能力。除此之外，借助于本章的学习，Rust还能够自动清除那些所有者离开了作用域的数据。这极大地减轻了使用者的心智负担，也不需要专门去编写销毁代码和测试代码。所有权影响了Rust中大部分功能的运作机制，有关这些概念的深入讨论会在后续展开。下一章将会一起来学习Rust如何使用struct来组装不同的数据。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust基础]]></title>
        <id>https://ttlv.github.io/blog/post/rust-base/</id>
        <link href="https://ttlv.github.io/blog/post/rust-base/">
        </link>
        <updated>2021-01-17T09:41:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="rust基础通用编程概念">Rust基础(通用编程概念)</h1>
<h2 id="1-变量">1. 变量</h2>
<h3 id="1-不可变量默认">1. 不可变量(默认)</h3>
<p>Rust的变量默认是不可变的,Rust这一设计的目的是为了可以方便的写出复杂的甚至是并行的代码。当然Rust的变量也不是一直不变的,Rust也提供了可以修改变量的方法。</p>
<p>接下来会用一段简单的代码去证书Rust的变量默认是不可变的特性，用Cargo new一个叫variables的项目</p>
<pre><code class="language-bash">cargo new variables
vim variables/src/main.rs
</code></pre>
<pre><code class="language-rust">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {}&quot;,x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;,x);
}
</code></pre>
<pre><code class="language-shell">cd variables/src
cargo run
</code></pre>
<p>在 variables/src 目录下在终端执行 cargo run命令,会得到下面的结果</p>
<pre><code class="language-shell">error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: make this binding mutable: `mut x`
3 |     println!(&quot;The value of x is: {}&quot;,x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0384`.
error: could not compile `rust_for_test`.

To learn more, run the command again with --verbose. 
</code></pre>
<p>编译器给出了一个错误 ***&quot;cannot assign twice to immutable variable <code>x</code>&quot;*<strong>意思是不能对不可变比变量进行二次赋值,代码中</strong>x = 6;<strong>这句话就对变量进行了二次赋值。(其实在还没有执行cargo run的命令的时候IDE的Rust的插件在</strong>x = 6;**已经用红线下滑标注错误了,我使用的是vscode)或许对于其他的语言,如Java，golang，python等等这些高级语言.按照这么写编译器不会给出这样的错。Rust这么设计的原因就是在很多情况下我们的代码很可能是依赖于绑定在这个变量上不可变的值，一旦这个值改变了，我们的程序很可能就不会按照我们的意愿去执行最后得到一个我们不期望得到的结果。而且这种bug往往是难以定位的，特别是修改操作在某些条件下偶然发生的时候。Rust的编译器可以准确的定位出问题对于开发人员来说是非常重要的，即便开发人员都不喜欢看到这种编译提示信息。</p>
<p>正因为Rust编译器可以保证那些申明为不可变的值一定不会发生改变。这就意味着你无需在阅读和编写代码时追踪一个变量会如何变化，从而简化的代码的逻辑的理解和推导。</p>
<h3 id="2-可变量">2. 可变量</h3>
<p>在上面也提到过Rust的变量也可以是可变的,需要你在申明变量的时候在前面加上<strong>mut</strong>关键字,有了这个关键字Rust就可以知道改变量是可变的。<strong>mut</strong>这个关键字除了使变量值可变之外,<strong>mut</strong>还会向阅读代码的人暗示其它代码可能会改变这个变量的值。</p>
<p>eg:我们继续修改上面的代码</p>
<pre><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {}&quot;,x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;,x);
}
</code></pre>
<p>运行上述代码结果如下</p>
<pre><code class="language-shell">cargo run
Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/rust_for_test`
The value of x is: 5
The value of x is: 6
</code></pre>
<p>因为<strong>mut</strong>关键字我们可以合法的将x绑定的值从5修改成6,相对于不可变量而言,可变变量会让代码变得更加易于编写。</p>
<p>除了避免出现bug，设计一个变量的可变性还要考量许多因素。例如当你在使用某些重型数据结构时，适当的使用可变性去修改一个实例，可能比赋值和重新返回一个新分配的实例要更有效率；而当数据结构较为轻量的时候,采用更加偏向函数式的风格,通过创建新变量来进行赋值，可能会使代码更加易于理解。在类似这样的情形下，为了可读性而损失少许的性能也许也是值得的。</p>
<h2 id="2-常量">2. 常量</h2>
<p>与变量相对的概念就是常量(constant),Rust中的常量与变量中的不可变量一样，绑定到常量上的值无法被其他代码修改，但是需要注意的常量与变量的不可变量还是存在着细微的差别。</p>
<h2 id="3-变量与常量直接的差别">3. 变量与常量直接的差别</h2>
<h3 id="1-语法层面">1.  语法层面</h3>
<ol>
<li>
<p>常量是不可以用<strong>mut</strong>的语法去修饰的。常量不仅默认是不可变的，不管发生什么情况，Rust中的常量无论如何都是不变的。</p>
</li>
<li>
<p>常量使用<strong>const</strong>关键字而不是使用<strong>let</strong>.</p>
</li>
<li>
<p>常量总是需要标注数据类型。</p>
</li>
<li>
<p>只能将常量绑定到常量表达式上，无法将一个函数的返回值或者其他需要在运行时计算的值绑定到常量上。</p>
</li>
</ol>
<h3 id="2-函数作用域">2. 函数作用域</h3>
<p>常量可以可以被声明在任何的作用域中，甚至包括全局的作用域。这在一个值需要被不同部分的代码共同引用时十分有用。</p>
<h3 id="3-常量声明语法示例">3. 常量声明语法示例</h3>
<p>eg:</p>
<pre><code class="language-rust">const MAX_POINTS: u32 = 100_000;
</code></pre>
<p>常量在这个程序运行的过程中都在自己声明的作用域内有效，这使得常量可以被用于在程序的不同代码之间共享值。</p>
<h3 id="4-常量的意义">4. 常量的意义</h3>
<p>将整个程序中硬编码的值声明为常量并给予其有意义的名字，可以帮助后来维护去理解这些值的意义，而使用同一常量来索引相同的硬编码值也能为将来的修改提供方便。</p>
<h2 id="4-隐藏">4. 隐藏</h2>
<pre><code class="language-rust">fn main() {
  let  x = 5;
  let x = x + 1;
  let x = x * 2;
  println!(&quot;The value of x is: {}&quot;,x)
}
</code></pre>
<pre><code class="language-shell">cargo run 
Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
  Finished dev [unoptimized + debuginfo] target(s) in 1.16s
   Running `target/debug/rust_for_test`
The value of x is: 12
</code></pre>
<p>上述的代码的执行结果正常输出,用<strong>let</strong>定义了一个叫X的变量,从上面的讲解中我们可以知道Rust中的变量默认是不可改变的,而且这里也没有使用mut关键字,结果是编译正常通过,而且x的值被修改了得到了我们期待的结果。用Rust的语法去理解上述的代码就要引出一个概念--<strong>隐藏(shadow)</strong>。第一个变量被第二个变量隐藏了。这意味着我们随后使用这个变量时，值一直是最后指向的值。我们可以重复使用let关键字并配以相同的名称来不断的隐藏变量。</p>
<p>上面的代码将x绑定到值5上。随后它又通过重复let x = 语句隐藏了第一个x的变量，并将第一个x变量值加上1的运算结果绑定到新的变量x上，这时x的值是6.第三个let的语句同样隐藏了第二个x变量，并将第二个x变量值乘以2的结果12绑定到第三个x变量上。</p>
<h3 id="1-shadow与mut的区别">1. shadow与mut的区别</h3>
<h4 id="1-区别1">1. 区别1</h4>
<p>隐藏机制不同于将一个变量声明为mut，因为如果不是在使用let关键字的情况下重新为这个变量赋值，则会导致编译错误。通过使用let，我们可以对这个值执行一系列的变换操作，并允许这个变量在操作完成后保持自己的不可变性。</p>
<h4 id="2-区别2">2. 区别2</h4>
<p>隐藏于mut的另一个区别在于: 由于重复使用let关键字会创建出新的变量，所以我们可以在复用变量名称的同时改变它的类型。例如，假设程序需要根据用户输入的空格数来决定文本之间的距离，那么我们可能会把输入的空格存储为一个独立的数值:</p>
<pre><code class="language-rust">let spaces = &quot;  &quot;;
let spaces = spaces.len();
</code></pre>
<p>这段代码可以生效是因为声明的第一个变量spaces是字符串类型，而第二个spaces虽然与第一个spaces的名称相同但是数据类型不一样，即隐藏机制运行我们复用spaces这个简单的名字，无需做出诸如spaces_num和spaces_str之类的区分。mut不支持这种方式</p>
<pre><code class="language-rust">let mut spaces = &quot;  &quot;;
spaces = spaces.len();
</code></pre>
<pre><code class="language-shell">error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `rust_for_test`.

To learn more, run the command again with --verbose.
</code></pre>
<p>从编译器给出的结果可以看出编译器是拒绝我们修改变量的类型的。</p>
<h2 id="5-数据类型">5. 数据类型</h2>
<p>Rust是一门静态语言，所以每一个值都有其特定的数据类型，Rust会根据数据的类型来决定该如何处理它们。我们会讨论两种不同的数据类型型子集：标量类型(scalar)和复合类型(compound)。</p>
<p>因为Rust是一门静态语言，所有的静态语言在编译中都需要知道变量的具体数据类型。在大部分情况下，编译器都可以根据我们如何绑定，使用变量的值来自动推导出变量的类型。如：</p>
<pre><code class="language-rust">let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
</code></pre>
<p>假设我们不提前指定数据类型</p>
<pre><code class="language-rust">let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
</code></pre>
<p>编译器会给我这样一个结果</p>
<pre><code class="language-shell"> --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^ consider giving `guess` a type

error: aborting due to previous error

For more information about this error, try `rustc --explain E0282`.
error: could not compile `rust_for_test`.

To learn more, run the command again with --verbose.
</code></pre>
<p>编译器告诉我们无法推导出变量的类型，为了便面混淆，它需要我们手动地添加类型标注。接下来，你会看到不同数据类型的类型标注方式。</p>
<h3 id="1-标量类型">1. 标量类型</h3>
<p>标量类型是单个值类型的统称。Rust中内建了4种基础的标量类型：整数，浮点数，布尔值以及字符。其他高级语言也一定含有这几种最最基础的数据类型。下面会介绍这几个数据类型在Rust中是怎么工作的。</p>
<h4 id="1-整数类型">1. 整数类型</h4>
<p>整数是指那些没有小数部分的整数。</p>
<table>
<thead>
<tr>
<th style="text-align:center">长度</th>
<th style="text-align:center">有符号</th>
<th style="text-align:center">无符号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">8-bit</td>
<td style="text-align:center">i8</td>
<td style="text-align:center">u8</td>
</tr>
<tr>
<td style="text-align:center">16-bit</td>
<td style="text-align:center">i16</td>
<td style="text-align:center">u16</td>
</tr>
<tr>
<td style="text-align:center">32-bit</td>
<td style="text-align:center">i32</td>
<td style="text-align:center">u32</td>
</tr>
<tr>
<td style="text-align:center">64-bit</td>
<td style="text-align:center">i64</td>
<td style="text-align:center">u64</td>
</tr>
<tr>
<td style="text-align:center">arch</td>
<td style="text-align:center">isize</td>
<td style="text-align:center">usize</td>
</tr>
</tbody>
</table>
<p>每一个整数类型的变体都会标明自身是否存在符号，并且拥有一个明确的大小。有符号和无符号代表一个整数类型是否拥有描述负数的能力。对于有符号的整数类型来讲，数值需要一个符号来表示当前是否为正，而对于无符号类型而言，数值永远为正，不需要符号。有符号数是通过二进制补码的形式来存储的。</p>
<p>对于一个位数为n的有符号类型整数，它可以存储从-(2<sup>n-1)到2</sup>n - 1范围内所有的整数。</p>
<p>除了指明位数的类型，还有isize和usize两种特殊的整数类型，它们的长度取决于程序运行的目标平台。在64位架构上，就是64位的，而在32位架构上就是32位的。</p>
<p>Rust中整数的字面量</p>
<table>
<thead>
<tr>
<th style="text-align:center">整数字面量</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Decimal</td>
<td style="text-align:center">98_222</td>
</tr>
<tr>
<td style="text-align:center">Hex</td>
<td style="text-align:center">0xff</td>
</tr>
<tr>
<td style="text-align:center">Octal</td>
<td style="text-align:center">0o77</td>
</tr>
<tr>
<td style="text-align:center">Binary</td>
<td style="text-align:center">0b1111_0000</td>
</tr>
<tr>
<td style="text-align:center">Byte(u8 only)</td>
<td style="text-align:center">b'A'</td>
</tr>
</tbody>
</table>
<p>在这么多的整数类型中，具体怎么选择，如果拿不定主意，Rust对于整数字面量的默认推到类型i32通常是一个很好的选择：他在大部分情形下都是运算速度最快的那一个，即便是在64位系统上也是如此。较为特殊的两个整数类型就是isize和usize则主要用于某些集合的索引。</p>
<h4 id="2-浮点数类型">2. 浮点数类型</h4>
<p>除了整数，Rust还提供了两种基础的浮点数类型，浮点数也就是带小数的数字。这两种类型f32和f64，他们分别占用32和64位空间。由于在现代CPU中f64与f32的运行效率几乎相差无几，却拥有更高 的精度，所以在Rust中，默认会将浮点数字面量的类型推到为f64.</p>
<pre><code class="language-rust">src/main.rs 
fn main(){
let x = 2.0 // f64
let y:f32 = 3.0 // f32
}
</code></pre>
<p>上面的代码展示了Rust的浮点数用了IEEE-754标准来进行表述，f32和f64类型分别对应着标准中的单精度浮点数数和双精度浮点数。</p>
<h4 id="3-数值运算">3. 数值运算</h4>
<p>Rut支持常见的数学运算:加法,减法,乘法,除法,以及取余。下面的代码展示了如何在let语句中使用这些运算</p>
<pre><code class="language-rust">src/main.rs 
fn main(){
  // 加法
  let sum = 5 + 10;
  //减法
  let difference = 99.5 - 4.5;
  // 乘法
  let product = 4 * 30;
  // 除法
  let quptient = 56.7/32.2;
  //取余
  let remainder = 43%5;
}
</code></pre>
<h4 id="4-布尔类型">4. 布尔类型</h4>
<p>和其他语言一样，Rust的布尔类型也只有两个值:true和false，占用两个字节的空间大小，我们用bool来表示一个布尔类型，例如</p>
<pre><code class="language-rust">src/main.rs fn main(){
  let t = true;
  let f:bool = false; // 附带了显示类型标准的语句
}
</code></pre>
<p>布尔类型主要是用在if表达式中作为条件使用，主要用于代码逻辑的控制流。</p>
<h4 id="5-字符类型">5. 字符类型</h4>
<p>Rust和其他语言一样同样也有相应的字符类型支持，在Rust中，char类型用于描述语言中最基础的单个字符。char类型使用单引号指定，而不同于字符串使用双引号指定。</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    let c = 'x';
    let z = 'Z';
    let pig = '🐷';
}
</code></pre>
<p>Rust中char类型占4个字节，是一个Unicode标量值，可以比ASCII表示更多的字符内容。拼音，中文，日文，韩文，零长度空字符串，甚至是emoji表情都可以作为一个有效的char类型值。实际上Unicode标量可以描述从U+0000到U+D7FF以及从U+E000到U+10FFFF范围内的所有值。由于Unicode中没有”字符“的概念，所以你现在从直觉上认为的”字符“也许与Rust的概念并不相符。在后续的分享中会仔细展开讨论。</p>
<h3 id="2-复合类型">2. 复合类型</h3>
<p>符合类型(compound type)可以将多个不同类型的值组合为一个类型。Rust提供了两种内置的基础复合类型: 元组(tuple)和数组(array).</p>
<h4 id="1-元组类型">1. 元组类型</h4>
<p>元组是一种常见的复合类型，它可以将其他不同类型的多个值组合进一个复合类型中。元组还拥有一个固定的长度：你无法声明结束后增加或减少其中的元素数量。</p>
<p>为了创建元组，我们需要一系列的值使用逗号分隔后放到有个圆括号中。元组每个位置的值都有一个类型，这些类型不需完全相同。如下代码</p>
<pre><code class="language-rust">src/main.rs 
fn main(){
    let tu
}
</code></pre>
<p>由于一个元组也被视作一个单独的复合元素，所以这里的变量tup被绑定到了整个元组上。为了从元组中获得单个的值，我们可以像如何的代码示例中来解构元组:</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    let tup:(i32,f64,u8) = (500,6.4,1);
    let (x,y,z) = tup;
    println!(&quot;The value of y is:{}&quot;,y)
}
</code></pre>
<p>这段程序首先创建了一个元组，并将其绑定到了变量tup上。随后，let关键字的右侧使用了一个模式将tup拆分为3个不同的部分:x,y和z,这个操作也被称为解构(destructing)。最后，程序将变量y的值，6.4打印了出来。</p>
<p>除了解构，我们还可以通过索引并使用点号(.)来访问元组中的值：</p>
<pre><code class="language-rust">fn main(){
    let tup:(i32,f64,u8) = (500,6.4,1);
    let five_hundred = tup.0;
    let six_point_four = tup.1;
    let one = tup.2;
}
</code></pre>
<p>这段程序首先创建了元组x,随后又通过索引访问元组的各个元素，并将它们的值绑定到新的变量上。和大多数编程语言一样，元组的索引从0开始。</p>
<h4 id="2-数组类型">2. 数组类型</h4>
<p>我们同样可以在数组中存储刀哥值的集合。与元组不同，数组中的每一个元素都必须是相同的类型。Rust中的数组拥有固定的长度，一旦声明了就再也不能随便改变大小，这与其他某些语言有所不同。</p>
<p>在Rust中，你可以将逗号分隔的值放置在一对方括号内来创建一个数组：</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    let array = [1,2,3,4,5];
}
</code></pre>
<p>通常而言，当你想在栈上而不是堆上为数据分配空间时，或是想要确保总有固定数量的元素时，数组是一个非常有用的工具。当然Rust的标准库也提供了一个更加灵活的动态数组(vector)类型。动态数组是一个类似于数组的集合结构，但他允许用户自由地调整整数组长度。这一点和golang的Slice(切片)类似。如果你不确定什么时候该使用数组什么时候该使用动态数组，默认就先使用动态数组。</p>
<p>在下面这张情况下，你也许会选择使用数组而非动态数组。假设在某一个程序中需要知道一年中每个月的名字，我们就可以使用数组来存储这个名字列表。因为我们知道它有且仅有12个元素，且不太可能添加或删除月份。</p>
<pre><code class="language-rust">let months = [&quot;January&quot;,&quot;February&quot;,&quot;March&quot;,&quot;April&quot;,&quot;May&quot;,&quot;June&quot;,&quot;July&quot;,&quot;August&quot;,&quot;September&quot;,&quot;October&quot;,&quot;November&quot;,&quot;December&quot;];
</code></pre>
<p>为了写出数组的类型，你需要一对方括号，并在方括号中填写数组内所有元素的类型，一个分号及数组内元素的数量，如下:</p>
<pre><code class="language-rust">let a:[i32;5] = [1, 2, 3, 4, 5];
</code></pre>
<p>示例中i32便是数组内所有元素的类型，而分号之后的5则表示数组的容量，示例中表示该数组可以塞5个元素。</p>
<p>这样撰写数组类型的方式有些类似于另一种初始化数组的语法，即假如你想要创建一个含有相同元素的数组，那么你可以再方括号中指定元素的值，并接着填入一个分号以及数组的长度，如下:</p>
<pre><code class="language-rust">let a = [3;5]
</code></pre>
<p>以a命名的数组将会拥有5个元素，而这些元素全部拥有相同的初始值3.这就等价于</p>
<pre><code class="language-rust">let a = [3, 3, 3, 3, 3]
</code></pre>
<h5 id="1-访问数组的元素">1. 访问数组的元素</h5>
<p>数组由一整块分配在栈上的内存组成，你可以通过索引来访问一个数组中的所有元素，就像下面的演示:</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    let array = [1,2,3,4,5];
    let first = array[0];
    let second = array[1];
}
</code></pre>
<p>在这个例子中，first变量会被赋值为1，这正是数组中索引[0]对应的那个值。同样，second变量将会获得数组中索引[1]对应的那个值，也就是2.</p>
<h5 id="2-非法的数组访问">2. 非法的数组访问</h5>
<p>尝试访问数组结尾之后的元素会发生些什么，我们可以把例子改成这样:</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    let array = [1,2,3,4,5];
    let index = 10;
    let element = array[index];
    println!(&quot;The value of element is:{}&quot;,element);
}
</code></pre>
<p>使用cargo run命令运行，我们会看到如下的结果</p>
<pre><code class="language-shell">error: this operation will panic at runtime
 --&gt; src/main.rs:4:19
  |
4 |     let element = array[index];
  |                   ^^^^^^^^^^^^ index out of bounds: the len is 5 but the index is 10
  |
  = note: `#[deny(unconditional_panic)]` on by default

error: aborting due to previous error

error: could not compile `rust_for_test`.

To learn more, run the command again with --verbose.
</code></pre>
<p>编译没有问题，但是程序却抛出了一个运行时的错误。实际上，每次通过索引来访问一个元素时，Rust都会检查这个索引是否小于当前数组的长度。加入索引超出了当前数组的长度，Rust就会发生panic。</p>
<p>这是第一个涉及Rust安全原则的示例。有许多底层语言没有提供类似的检查，一旦尝试使用非法索引，你就会访问到某块无效的内存。在这种情况下，逻辑上的错误常常会蔓延至程序的其他部分，进而产生无法料想的结果。通过立即中断程序而不是自作主张的去继续运行，Rust帮助我们避开了类似的错误。</p>
<h2 id="6-函数">6. 函数</h2>
<p>函数在任何的编程语言中都是一个及其重要的概念,Rust也是一样.我们知道Rust的入口就是main.rs文件中的main函数，不只是rust,大部分的程序开始入口也都是从main开始，比如C,比如go......Rust 函数的关键字是fn，可以用它来声明一个函数。</p>
<p>Rust代码使用蛇形命名法(snake case)来作为函数规范和变量名称的风格。蛇形命名法只用小写的字母进行命名，并以下划线分隔单词。下面是一个函数定义的示例:</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    println!(&quot;Hello World!&quot;);
    another_function();
}

fn another_function(){
    println!(&quot;Another function.&quot;)
}
</code></pre>
<p>在Rust中函数定义以fn关键字开始并紧随函数名称与一对圆括号，另外还有一对花括号用于标识函数体开始和结尾的地方。</p>
<p>我们可以使用函数名加圆括号的方式来调用函数。在上面的示例中，由于another_function被定义为了函数，所以我们可以在main函数体内调用它。需要注意的是，我们在这个例子中将another_function定义在了main函数之后，其实就算单把它放到main函数之前其实也没有影响，编译的结果是一样的。Rust不关心你在何处定义函数，只要这些定义对于使用区域是可见的即可。</p>
<p>现在我们创建一个新的二进制项目function来实践一下函数相关的功能。将上面another_function示例中的内容复制到文件src/main.rs中并运行它，下面试运行结果:</p>
<pre><code class="language-shell">    Finished dev [unoptimized + debuginfo] target(s) in 0.10s
     Running `target/debug/rust_for_test`
Hello World!
Another function.
</code></pre>
<p>正如我们预料的那样，代码以它们出现在main函数中的顺序依次执行了出来。首先，&quot;Hello World&quot;这条信息将被打印出来，紧接着another_function函数得到执行，将函数体内的信息也打印出来。</p>
<h3 id="1-函数参数">1 . 函数参数</h3>
<p>我们可以在函数声明中定义参数(parameter),它们是一种特殊的变量，并被视作函数签名的一部分。当函数存在参数时，你需要在调用函数时为这些变量提供具体的值。在文档中，参数变量和传入的具体参数值有自己分别对应的名称parameter和argument,但我们通常会混用两者并将它们统一称为参数而不加以区别。</p>
<p>下面重写后的another_function函数展示了Rust中参数的样子。</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    another_function(5);
}

fn another_function(x:i32){
    println!(&quot;The value of x is {}.&quot;,x);
}
</code></pre>
<p>尝试运行这段程序可以得到如下所示的输出:</p>
<pre><code class="language-shell"> Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
  Finished dev [unoptimized + debuginfo] target(s) in 0.34s
   Running `target/debug/rust_for_test`
The value of x is 5.
</code></pre>
<p>这里定义的another_function有一个名为x且类型为i32的参数。当5被传入another_function时，println!宏会将5放入格式化字符串中的特定位置并打印出来。</p>
<p>在函数签名中，必须显示的声明每个参数的类型。这是在Rust设计中设计者们经过慎重考虑后作出的决定:由于类型被显示的注明了,因此编译器不需要通过其他部分的代码进行推导就能明确的知道意图。</p>
<p>另外，你可以像下面一样，通过使用逗号分隔符来为函数声明多个参数:</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    another_function(5,6);
}

fn another_function(x:i32,y:i32){
    println!(&quot;The value of x is {}.&quot;,x);
    println!(&quot;The value of y is {}.&quot;,y);
}
</code></pre>
<p>这了的示例创建一个拥有两个参数的函数,这个函数会依次打印出这两个参数。需要注意的是，函数参数可以是不同类型的，示例代码中恰好使用了两个i32类型的参数而已。</p>
<pre><code class="language-shell">   Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
    Finished dev [unoptimized + debuginfo] target(s) in 0.83s
     Running `target/debug/rust_for_test`
The value of x is 5.
The value of y is 6.
</code></pre>
<p>由于我们在调用函数时,将5和6分别做为x和y的值穿传入了函数,所以这两个字符串与他们的值被相应的打印出来。</p>
<h3 id="2-函数体中的语句和表达式">2. 函数体中的语句和表达式</h3>
<p>函数体由若干条语句组成，并可以以一个表达式作为结尾。虽然我们在语句中见到了许多表达式，但到目前为止，我们都还没有使用过表达式来结束一个函数。由于Rust是一门基于表达式的语言，所以它将语句(statement)与表达式(expression)区别为两个不同的概念。这与其他某些语言不同。因此，让我们首先来看一下语句和表达式究竟是什么，接着再进一步讨论他们之间的区别会如何影响函数体的定义过程。</p>
<h4 id="1-语句">1. 语句</h4>
<p>语句是指那些执行操作但不返回值的指令</p>
<h4 id="2表达式">2.表达式</h4>
<p>表达式则是指令进行计算并产生一个值作为结果的指令。</p>
<p>使用let关键字创建变量并绑定值时使用的指令是一条语句</p>
<pre><code class="language-rust">src/main.rs
fn main(){
   let y = 6;
}
</code></pre>
<p>重点是语句在Rust中绝对不会返回值，要是将一条let语句赋值给另外一个变量就会产生编译错误如</p>
<pre><code class="language-rust">src/main.rs
fn main(){
   let x = (let y = 6);
}  
</code></pre>
<pre><code class="language-shell">  Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
error[E0658]: `let` expressions in this position are experimental
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information
  = help: add `#![feature(let_chains)]` to the crate attributes to enable

error: `let` expressions are not supported here
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: only supported directly in conditions of `if`- and `while`-expressions
  = note: as well as when nested within `&amp;&amp;` and parenthesis in those conditions

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^^^^^^^^^^^ help: remove these parentheses
  |
  = note: `#[warn(unused_parens)]` on by default

error: aborting due to 2 previous errors; 1 warning emitted

For more information about this error, try `rustc --explain E0658`.
error: could not compile `rust_for_test`.

To learn more, run the command again with --verbose.
</code></pre>
<p>由于let y = 6语句没有返回任何值，所以变量x就没有可以绑定的东西。这里的行为与某些语言不同，例如C语言或者是Ruby重的赋值语句会返回所赋值的值。在这些语言中，可以编写类似于x = y = 6这样的语句，并使得x和y变量同时拥有6这个值，但这在Rust中可行不通。</p>
<p>与语句不同，表达式会计算初某个值来作为结果，你在Rust中编写大部分代码都会是表达式。以简便的数字运算 5 + 6 为例，这就是一个表达式，并且会计算出值为11。另外，表达式本身也可以作为语句的一部分，在前面的示例代码中有提到let y = 6；字面量6就是一个表达式，它返回6作为自己的计算结果。调用函数式表达式，调用宏是表达式，我们用来创建新作用域的花括号({})同样也是表达式，如</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    let x = 5; 
    ① let y = { ②
        let x = 3;
        ③ x + 1
    };
    println!(&quot;the value of y is {}&quot;,y)
}
</code></pre>
<p>②是一个代码块。在这个例子中，会计算出4为计算结果。而这个结果会作为let语句①的一部分被绑定到变量y上。注意结尾处③的表达式x+1没有添加分号，这与我们之前见过的大部分代码不同。假如我们在表达式的末尾加上了分号，这一段代码就变成了语句而不会返回任何值。</p>
<h4 id="3-函数的返回值">3. 函数的返回值</h4>
<p>函数可以向调用它的代码返回值。虽然你不用为这个返回值命名，但需要在肩头符号(-&gt;)的后面声明它的类型。在Rust中，函数的返回值等同于函数体最后一个表达式的值。熟悉Ruby的朋友应该就很熟悉了。你也可以使用return关键字并指定一个值来提前从函数中返回，但大多数函数都隐式返回最后的表达式，如:</p>
<pre><code class="language-rust">src/main.rs
fn five() -&gt; i32{
    5
}

fn main(){
    let x = five();
    println!(&quot;The value of x is {}&quot;,x)
}
</code></pre>
<p>five函数除了5，没有任何其他的函数调用，宏调用，甚至是let语句，但它在Rust中确实是一个有效的函数。five函数的返回值通过-&gt; i32被绑定了，运行代码会看到如下的输出:</p>
<pre><code class="language-shell">   Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
    Finished dev [unoptimized + debuginfo] target(s) in 1.74s
     Running `target/debug/rust_for_test`
The value of x is 5
</code></pre>
<p>five函数中5就是函数的输出值，这也是它的返回值，返回值被声明成i32.这里有两个需要注意的地方。首先，语句let x = five();使用函数的返回值来初始化左侧的变量。由于five函数总是返回5，所以该代码等价于:</p>
<pre><code class="language-rust">let x = 5;
</code></pre>
<p>其次，这里的five的函数没有参数，仅仅定义了返回的类型。函数中除了5之外没有任何的东西，5即是我们想要的结果作为返回的表达式。再如</p>
<pre><code class="language-rust">src/main.rs
fn plus_one(x:i32) -&gt; i32{
    x+1
}

fn main(){
    let x = plus_one(5);
    println!(&quot;The value of x is {}&quot;,x)
}
</code></pre>
<p>运行结果</p>
<pre><code class="language-shell">   Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/rust_for_test`
The value of x is 6
</code></pre>
<p>运行结果是The value of x is 6，如果将plus_one()函数改为</p>
<pre><code class="language-rust">fn plus_one(x:i32) -&gt; i32{
    x+1;
}
</code></pre>
<p>表达式就会因为变味语句而导致编译错误。</p>
<pre><code class="language-rust">src/main.rs
fn plus_one(x:i32) -&gt; i32{
    x+1;
}

fn main(){
    let x = plus_one(5);
    println!(&quot;The value of x is {}&quot;,x)
}
</code></pre>
<pre><code class="language-shell"> Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
error[E0308]: mismatched types
--&gt; src/main.rs:1:23
|
1 | fn plus_one(x:i32) -&gt; i32{
|    --------           ^^^ expected `i32`, found `()`
|    |
|    implicitly returns `()` as its body has no tail or `return` expression
2 |     x+1;
|        - help: consider removing this semicolon

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `rust_for_test`.

To learn more, run the command again with --verbose.
</code></pre>
<p>我们看到错误的第二行的内容<strong>error[E0308]: mismatched types</strong>意思是类型不匹配，和明显的可以看出在定义plus_one的过程中声明它会返回一个i32类型的值。由于语句不会产生值，所以Rust就默认返回了一个空元祖，也就是上述编译结果中的().这与我们预先设置的返回i32类型相矛盾，所以导致了这样的编译错误。</p>
<h5 id="1-题外话">1. 题外话</h5>
<p>Rust编译器的错误提示信息中还提示了一个可能修正错误的方案，它建议我们去掉函数末尾的分号去解决这个问题。</p>
<h4 id="4-注释">4. 注释</h4>
<p>有一定代码基础的同学对注释(comment)这个概念再熟悉不过了，注释的存在的意义也在于程序员可以在源代码中留下记录,编译器在编译时回忽略这些注释，使得阅读代码的人可以通过注释更好的理解你的意图，如:</p>
<pre><code class="language-rust">// Hello,World.
</code></pre>
<p>在Rust中，注释必须使用两到斜杠开始，并持续到本行末尾。对于那些超过一行的注释，必须在每一行前面都加上//.</p>
<p>注释同样也可以放在代码行的末尾处。</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    let kucky_number = 7; // I'm feeling lucky today.
}
</code></pre>
<p>不过你可能会更加常见到下面这种格式，在需要说明的代码上方需单独放置一行注释:</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    // I’m feeling lucky today
    let lucky_number = 7;
}
</code></pre>
<h4 id="5-控制流">5 控制流</h4>
<p>通过条件来执行或重复执行默写代码是大部分编程语言的基础组成部分。在Rust中用来控制程序执行流的结构主要就是if表达式与循环表达式。</p>
<h5 id="1-if表达式">1. if表达式</h5>
<p>if表达式允许我们根据条件执行不同的代码分支。我们提供一个条件，并且做出声明:&quot;假如这个条件满足，则运行这段代码。假如条件没有被满足，则跳过相应的代码。&quot;</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    let number = 3;
    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    }else{
        println!(&quot;condition was false&quot;);
    }
}
</code></pre>
<p>所有的if表达式都会用if关键字来开头，并紧随一个判断条件。上面的代码的使用if判断number对象的值是否小于5。花括号中放置了条件为真时需要执行的代码片段。if表达式中与条件相关的代码块也称为分支(arm)。与Rust中的match表达式一样。</p>
<p>执行结果:</p>
<pre><code>   Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
    Finished dev [unoptimized + debuginfo] target(s) in 5.06s
     Running `target/debug/rust_for_test`
condition was true
</code></pre>
<p>修改number的值</p>
<pre><code class="language-rust">let number = 7;
</code></pre>
<p>执行结果</p>
<pre><code>   Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
    Finished dev [unoptimized + debuginfo] target(s) in 0.80s
     Running `target/debug/rust_for_test`
condition was false
</code></pre>
<p>if表达式的使用很简单，但需要注意一点。代码中的条件表达式必须产生一个bool类型的值，否则会产生编译错误。</p>
<pre><code>   Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:8
  |
3 |     if number {
  |        ^^^^^^ expected `bool`, found integer

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `rust_for_test`.

To learn more, run the command again with --verbose.
The terminal process terminated with exit code: 101
</code></pre>
<p>这个错误表明Rust期待在条件表达式中得到一个bool值，而不是一个整数。这与Ruby或者JavaScript等语言不用，Rust不会自动尝试将非布尔类型的值转为布尔类型。你必须显示地在if表达式中提供一个布尔类型作为条件，加入你想要if代码块只在数字不等于0时运行。那么我们可以将if表达式修改为:</p>
<pre><code>src/main.rs
fn main(){
    let number = 7;
    if number!=0 {
        println!(&quot;number was something other than zero&quot;);
    }
}
</code></pre>
<p>运行这段代码将会输出number was something other than zero。</p>
<p>使用else if实现多重判断，你可以使用组合if,else以及else if表达式实现多重陪条件判断。如:</p>
<pre><code class="language-rust">src/main
fn main(){
    let number = 6;
    if number % 4 ==0{
        println!(&quot;number is divisible by 4&quot;);
    }else if number % 3 == 0{
        println!(&quot;number is divisible by 3&quot;);
    }else if number % 2 == 0{
        println!(&quot;number is divisible by 2&quot;);
    }else{
        println!(&quot;number is divisible by 4,3 or 2&quot;);
    }
}
</code></pre>
<p>这段程序拥有4条可能执行的路径，运行后可以看到结果</p>
<pre><code>   Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
    Finished dev [unoptimized + debuginfo] target(s) in 0.76s
     Running `target/debug/rust_for_test`
number is divisible by 3
</code></pre>
<p>这段程序运行时，它会依次检查每一个if表达式，并执行条件受限被判断为真的代码片段。尽管6可以被2整除，但我们既没有看到输出 println!(&quot;number is divisible by 2&quot;);也没有看到else代码块中的println!(&quot;number is divisible by 4,3 or 2&quot;);被输出。这是因为Rust会且仅会执行第一个条件为真的代码块，一旦发现满足条件，它便不会在继续检查剩下的那些条件分支了。</p>
<p>当然，过多的else if表达式可能会使我们的代码变得杂乱无章。后面会讲到match的用法，用match可以处理这种条件过多的情况。</p>
<p>在let 语句中使用if</p>
<p>由于if是一个表达式，所以我们可以在let语句的右侧使用它来生成一个值。如:</p>
<pre><code class="language-rust">src/main.rs
fn main(){
 let condition = true;
 let number = if condition {
     5
 }else{
     6
 };
 println!(&quot;The value of number is:{}&quot;,number);
}
</code></pre>
<p>上面的代码的number变量被绑定到了if表达式的输出结果上面。运行这段代码可以看到如下的结果:</p>
<pre><code>   Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
    Finished dev [unoptimized + debuginfo] target(s) in 0.51s
     Running `target/debug/rust_for_test`
The value of number is:5
</code></pre>
<p>代码块输出的值就是其中最后一个表达式的值。另外，数字本身也可以作为一个表达式使用，在上面的例子中，整个if表达式的值取决于究竟哪一个代码块得到了执行。这也意味着，所有if分支可能返回的值都必须是一种类型的；上面的代码if分支与else分支的结果都是i32类型的整数。假如分支表达式产生的类型无法匹配，那么就会触发编译错误，如下:</p>
<pre><code class="language-rust">src/main.rs
fn main(){
 let condition = true;
 let number = if condition {
     5
 }else{
     &quot;six&quot;
 };
 println!(&quot;The value of number is:{}&quot;,number);
}
</code></pre>
<p>结果如下:</p>
<pre><code>   Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:6:6
  |
3 |    let number = if condition {
  |  _______________-
4 | |      5
  | |      - expected because of this
5 | |  }else{
6 | |      &quot;six&quot;
  | |      ^^^^^ expected integer, found `&amp;str`
7 | |  };
  | |__- `if` and `else` have incompatible types

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `rust_for_test`.

To learn more, run the command again with --verbose.
The terminal process terminated with exit code: 101
</code></pre>
<p>第一个if返回一个i32类型的整数，else返回了一个值为“six”的字符串，变量只能拥有一种类型，所以这段代码无法通过编译。为了对其他使用number变量的代码进行编译时类型检查，Rust需要在编译时确定number的具体类型。如果Rust能够使用运行时确定的number类型，那么它就不得不记录所有可能出现的类型，这会使得代码编译器的实现更加复杂，并丧失许多代码安全保障。</p>
<h5 id="2-使用循环重复执行代码">2. 使用循环重复执行代码</h5>
<p>我们常常需要重复执行同一行代码，针对这张场景，Rust提供了循环(loop)工具，一个循环会执行循环中的代码直到结尾，并紧接着回到开头继续执行。</p>
<p>Rust提供了三种循环:loop,while和for。</p>
<h6 id="1-使用loop循环">1 使用loop循环</h6>
<p>我们可以使用loop关键字指示Rust反复执行一段代码，直到我们显示的退出为止。</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    loop{
        println!(&quot;again&quot;)
    }
}
</code></pre>
<p>运行这段程序时，除非我们手动强制退出程序，否则again会被反复地stdout输出。大部分终端都支持Ctrl+C来终止这种死循环。</p>
<pre><code class="language-shell">    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/rust_for_test`
again
again
again
....... //全是again的输出
^Cagain
</code></pre>
<p>这里的符号<sup>C就是我们按下了快捷键Ctrl+C。在</sup>C后面可能看得到again输出也有可能看不到，这取决于程序在接收到退出信号时执行到了哪一步。</p>
<p>让然Rust提供了另外一种更加可靠的循环退出方式，你可以再循环中使用break关键字来通知程序退出循环。</p>
<h6 id="2-从loop循环中返回值">2 从loop循环中返回值</h6>
<p>loop循环可以被用来反复尝试一些可能会失败的操作，比如检查某个线程是否完成了工作。不管怎么样，你也许需要将该操作的结果传递给余下的代码。为了实现这一目的，我们返回值添加到brake表达式之后，也就是我们用来终止循环表达式的后面。接着你可以再代码中使用loop循环来返回值了。如</p>
<pre><code class="language-rust">src/main
fn main(){
    let mut counter = 8;

    let result = loop{
        counter += 1;

        if counter == 10{
            break counter * 2;
        }
    };

    println!(&quot;The result is {}&quot;,result);
}
</code></pre>
<p>我们在循环前声明了变量counter并将其初始化为0。接着我们声明了一个名为result的变量来存储循环中返回的值。该循环会在每次迭代时给count变量的值加1，并检查计数器是否已经增至10.一旦条件符合，我们便使用break关键字返回counter * 2.在循环之后我们还是用了一个分号来结束当前的语句，这回将循环的返回结果赋值给result。最终，我们会打印出result内存储的值，也就是20</p>
<p>执行结果</p>
<pre><code class="language-shell">    Finished dev [unoptimized + debuginfo] target(s) in 0.14s
     Running `target/debug/rust_for_test`
The result is 20
</code></pre>
<h6 id="3-while条件循环">3 while条件循环</h6>
<p>另外一种常见的循环就是在每次执行循环体之前都判断一次条件，假如条件为真则执行代码片段，假如条件为假或在执行过程中碰到break就退出当前循环。这种模式可以通过loop，if,else以及break关键字的组合使用来实现。</p>
<p>由于这种模式太过于常见，Rust提供了一个内置的语言结构:While循环。如下面的代码示例，程序会执行3次，每次减1，在循环结束之后打印出特定的消息并退出。</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    let mut number = 3;
    while number!=0{
        println!(&quot;{}!&quot;,number);

        number = number - 1;
    }
    println!(&quot;LIFTOFF!!!&quot;)
}
</code></pre>
<p>如果使用if,else,break去实现上面的逻辑，会有很多的冗余代码，使用while会使代码的逻辑结构更加清晰。当条件为真时，来实行循环体中的代码，否则就退出循环。</p>
<p>执行结果</p>
<pre><code class="language-shell">   Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
    Finished dev [unoptimized + debuginfo] target(s) in 1.41s
     Running `target/debug/rust_for_test`
3!
2!
1!
LIFTOFF!!!
</code></pre>
<h6 id="4-用for来循环遍历集合">4 用for来循环遍历集合</h6>
<p>你可以使用while结构来遍历诸如数组之类的集合中的元素，如:</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    let a = [10,20,30,40,50];
    let mut index = 0;
    while index &lt; 5 {
        println!(&quot;the value is:{}&quot;,a[index]);
        index += 1;
    }
}
</code></pre>
<p>上面的代码会对数组中的所有元素进行一个遍历的输出，index从0开始，每次经过一次循环index都会加1，知道加到5就退出。</p>
<p>执行结果</p>
<pre><code class="language-shell">   Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
    Finished dev [unoptimized + debuginfo] target(s) in 0.56s
     Running `target/debug/rust_for_test`
the value is:10
the value is:20
the value is:30
the value is:40
the value is:50
</code></pre>
<p>如同我们预料的那样，数组中的5个元素都被输出到了终端上，尽管index会在摸个时候变成5，但是循环会在我们尝试越界去访问数组的第六个数值之前停止。</p>
<p>需要指出的是，类似的代码非常容易出错，可能会因为使用了不正确的索引长度而使程序崩溃。而且，由于我们运行时代码来对每一次遍历做出判断啊，所以这段代码的运行效率会比较低。</p>
<p>你可以使用for循环让这种循环变得更加的简单明了。如:</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    let a = [10,20,30,40,50];
    for element in a.iter(){
        println!(&quot;the value is:{}&quot;,element)
    }
}
</code></pre>
<p>执行结果：</p>
<pre><code class="language-shell">   Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
    Finished dev [unoptimized + debuginfo] target(s) in 0.90s
     Running `target/debug/rust_for_test`
the value is:10
the value is:20
the value is:30
the value is:40
the value is:50
</code></pre>
<p>结果和用while实现的代码的结果一样，但是重要的是我们增强了代码的安全性，不会出现越界访问或者是漏掉某些元素之类的问题。</p>
<p>例如在这段代码中</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    let a = [10,20,30,40,50];
    let mut index = 0;
    while index &lt; 5 {
        println!(&quot;the value is:{}&quot;,a[index]);
        index += 1;
    }
}
</code></pre>
<p>假如我们从a数组中移除了某个元素，却忘记将循环中的条件更新为while index&lt;4，那么在运行代码就会发生崩溃。而使用for循环的话，就不需要市场惦记着在更新数组元素数量时还要去修改别的代码。</p>
<p>for循环的安全性和简洁性成为了Rust中最为常见的循环结构。即便是为了实现类似如下的代码，要执行特定次数的循环任务，大部分的</p>
<pre><code class="language-rust">src/main.rs
fn main(){
    let mut number = 3;
    while number!=0{
        println!(&quot;{}!&quot;,number);

        number = number - 1;
    }
    println!(&quot;LIFTOFF!!!&quot;)
}
</code></pre>
<p>Rust开发者也会优先选择使用for循环实现。我们可以配合标准库中提供的Range来实现这一目的，它被用来生成一个数字开始到另一个数字结束之前的所有数字序列。</p>
<p>上述的代码我想通过另外一个还未提及过的rev的方法来翻转Range生成的序列</p>
<pre><code class="language-rust">src/main.rs
fn main(){
for number in (1..4).rev(){
    println!(&quot;{}&quot;,number);
}
println!(&quot;LIFTOFF!&quot;);
}
</code></pre>
<p>执行结果</p>
<pre><code class="language-shell">   Compiling rust_for_test v0.1.0 (/Users/StevenLv/codes/rust/rust_for_test)
    Finished dev [unoptimized + debuginfo] target(s) in 0.75s
     Running `target/debug/rust_for_test`
3
2
1
LIFTOFF!
</code></pre>
<p>看上去是更加简洁了。</p>
<h2 id="7-总结">7. 总结</h2>
<p>以上是Rust基本语法中的全部内容，讲述了变量，标量和复合数据类型，函数，注释,if表达式，while循环以及for循环，掌握了以上的语法知识可以对Rust有一个初步的了解，下一章将讲述Rust很有的趣的所有权的内容。</p>
]]></content>
    </entry>
</feed>